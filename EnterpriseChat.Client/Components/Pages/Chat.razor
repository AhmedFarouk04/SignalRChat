@page "/chat/{RoomId:guid}"
@attribute [Microsoft.AspNetCore.Authorization.Authorize]
@using EnterpriseChat.Client.Authentication.Abstractions
@using EnterpriseChat.Client.Components.Reaction
@using EnterpriseChat.Client.Services.Realtime
@using EnterpriseChat.Client.Services.Ui
@using EnterpriseChat.Client.ViewModels
@using EnterpriseChat.Client.Models
@using EnterpriseChat.Domain.Enums
@using Microsoft.JSInterop
@using EnterpriseChat.Application.DTOs
@using EnterpriseChat.Client.Services.Http
@using EnterpriseChat.Client.Services.Attachments
@using Microsoft.AspNetCore.Components.Forms
@inject GroupsApi GroupsApi
@inject UsersApi UsersApi
@inject ChatViewModel VM
@inject NavigationManager Nav
@inject IJSRuntime JS
@inject RoomsViewModel RoomsVM
@inject EnterpriseChat.Client.Models.ReplyContext ReplyCtx
@inject AttachmentsApi AttachmentsApi
@implements IDisposable
@inject NotificationManager NotificationManager
@inject ICurrentUser CurrentUser
@inject IChatRealtimeClient Realtime

<div class="chat-page">
    @if (_showToast)
    {
        <div class="custom-toast">
            <span>@_toastMessage</span>
        </div>
    }

    <TopBar Room="@VM.Room"
            VM="@VM"
            OnScrollToMessage="ScrollToMessage"
            MembersCount="@(VM.GroupMembers?.Members.Count ?? 0)"
            OnlineCount="@VM.OnlineUsers.Count"
            OtherUser="@VM.OtherUser"
            IsMuted="@VM.IsMuted"
            IsBlockedByMe="@VM.IsBlockedByMe"
            OnMuteToggle="ToggleMute"
            OnBlock="BlockOtherUser"
            OnUnblock="UnblockOtherUser"
            OnMembers="OpenMembers" />

    @if (VM.UiError != null)
    {
        <div class="chat-error">@VM.UiError</div>
    }
    else if (VM.Room == null)
    {
        <div class="chat-error">This room no longer exists.</div>
    }
    else if (VM.IsRemoved)
    {
        <div class="chat-error">
            You were removed from this group.
            <button class="mini-btn" @onclick="@(() => Nav.NavigateTo("/rooms"))">Back to rooms</button>
        </div>
    }
    else
    {
        <div class="chat-body">
            @if (VM.IsDisconnected)
            {
                <div class="connection-banner">Reconnecting…</div>
            }

            <div class="chat-messages" id="chat-messages">
                @* ✅ استخدام Virtualize لتحسين الأداء ومنع إعادة إنشاء كل الرسائل *@
                <MessageList Messages="@VM.Messages"
                             CurrentUserId="@VM.CurrentUserId"
                             Room="@VM.Room"
                             GroupMembers="@(VM.GroupMembers?.Members ?? new())"
                             OnRetry="RetrySend"
                             OnReachedBottom="HandleReachedBottom"
                             OnReaction="OnReaction"
                             OnReplyRequested="HandleReplyRequest"
                             OnScrollToMessage="ScrollToMessage"
                             OnOpenReactionDetails="OpenReactionDetails"
                             OpenReactionMessageId="@OpenReactionMessageId"
                             OnToggleReaction="ToggleReaction"
                             OnEditRequested="StartEdit"
                             OnDeleteRequested="HandleDeleteRequested" />

                <div id="messages-end"></div>

                <TypingIndicator TypingUsers="@VM.TypingUsers" />

                @if (_reactionModalOpen && _reactionDetails != null)
                {
                    <ReactionDetailsModal Data="_reactionDetails"
                                          OnRemoveMyReaction="RemoveMyReaction"
                                          OnClose="CloseReactionDetails" />
                }
            </div>

            @if (_attachmentsOpen)
            {
                <div class="drawer-backdrop" @onclick="CloseAttachments"></div>
                <aside class="drawer" role="dialog" aria-modal="true" aria-label="Attachments drawer" tabindex="0">
                    <div class="drawer-header">
                        <div>
                            <div class="drawer-name">Attachments</div>
                            <div class="drawer-sub">Room files</div>
                        </div>
                        <button class="icon-btn" title="Close" @onclick="CloseAttachments" autofocus>✕</button>
                    </div>
                    <div class="drawer-list">
                        <ChatAttachments RoomId="RoomId" />
                    </div>
                </aside>
            }

            <div class="chat-input" @onclick="CloseAttachMenuIfOpen">
                @if (VM.IsOtherDeleted)
                {
                    <div class="blocked-banner">This user is no longer available.</div>
                }
                else if (VM.IsBlockedByMe)
                {
                    <div class="blocked-banner">You blocked this user. Unblock to send messages.</div>
                }
                else
                {
                    <div class="composer">
                        @if (ReplyCtx.MessageId != Guid.Empty)
                        {
                            <div class="reply-context">
                                <div class="reply-header">
                                    <span>Replying to @ReplyCtx.SenderName</span>
                                    <button class="cancel-reply" @onclick="ReplyCtx.Clear" type="button">✕</button>
                                </div>
                                <div class="reply-preview-text">@ReplyCtx.ContentPreview</div>
                            </div>
                        }
                        <div class="composer-box">
                            <button type="button" class="attach-btn" @onclick="ToggleAttachMenu" @onclick:stopPropagation="true" title="Attach">
                                📎
                            </button>
                            @if (_attachMenuOpen)
                            {
                                <div class="attach-popup" @onclick:stopPropagation="true">
                                    <button class="popup-item" @onclick="TriggerFileUpload">📄 Upload file</button>
                                    <button class="popup-item" @onclick="OpenAttachmentsDrawer">🗂️ View attachments</button>
                                </div>
                            }
                            <InputFile OnChange="OnFileSelected" multiple id="attach-file-input" style="display:none;" />
                            <textarea class="composer-input" @ref="inputRef"
                                      placeholder="@(ReplyCtx.MessageId != Guid.Empty ? "Type your reply…" : "Message…")"
                                      @bind="currentMessage" @bind:event="oninput" @onkeydown="OnKeyDown"></textarea>
                            <button class="composer-send" type="button"
                                    disabled="@string.IsNullOrWhiteSpace(currentMessage.Trim())" @onclick="SendMessage">
                                Send
                            </button>
                        </div>
                    </div>
                }
            </div>

            @if (_membersOpen && VM.Room?.Type == "Group")
            {
                <MembersDrawer IsOpen="_membersOpen"
                               Members="@VM.GetAllMembersForDrawer()"
                               OwnerId="@(VM.GroupMembers?.OwnerId ?? Guid.Empty)"
                               CurrentUserId="@VM.CurrentUserId"
                               GroupName="@VM.Room.Name"
                               CanManageMembers="@(VM.GroupMembers?.OwnerId == VM.CurrentUserId)"
                               OnRemove="RemoveMember"
                               OnAdd="HandleAddMemberFromDrawer"
                               OnRename="HandleRenameFromDrawer"
                               OnToggleAdmin="HandleToggleAdmin"
                               OnTransferOwner="HandleTransferOwner"
                               OnDelete="HandleDeleteGroup"
                               OnLeave="HandleLeaveFromDrawer"
                               OnClose="CloseMembers" />
            }

            @if (VM.IsSelectionMode)
            {
                <div class="forward-action-bar">
                    <div class="selection-info">
                        <button class="icon-btn close-btn" @onclick="() => VM.IsSelectionMode = false">✕</button>
                        <span>@VM.SelectedMessageIds.Count Selected</span>
                    </div>
                    <button class="forward-submit-btn @(VM.SelectedMessageIds.Any() ? "active" : "")"
                            disabled="@(!VM.SelectedMessageIds.Any())" @onclick="() => VM.IsForwardModalOpen = true">
                        Forward ➔
                    </button>
                </div>
            }
        </div>
    }

    <PinDurationModal IsOpen="VM.IsPinModalOpen" OnCancel="() => VM.IsPinModalOpen = false" OnConfirm="VM.ConfirmPinAsync" />
    <ForwardModal IsOpen="VM.IsForwardModalOpen" OnClose="() => VM.IsForwardModalOpen = false" />
</div>

@code {
    [Parameter] public Guid RoomId { get; set; }

    private bool _membersOpen;
    private bool _attachmentsOpen;
    private bool _attachMenuOpen;
    private bool _renderQueued;
    private string currentMessage = string.Empty;
    private ElementReference inputRef;
    private string _toastMessage = string.Empty;
    private bool _showToast = false;
    private DotNetObjectReference<ChatPageInterop>? _objRef;
    private bool _escapeRegistered;
    private IJSObjectReference? _chatModule;
    private CancellationTokenSource? _readCts;
    private Guid _lastSentReadId = Guid.Empty;
    private MessageReactionsDetailsDto? _reactionDetails;
    private bool _reactionModalOpen;
    private Guid _reactionMessageId;
    private Guid? OpenReactionMessageId;
    private MessageModel? _editingMessage;

    // ✅ متغيرات لتتبع التغييرات ومنع إعادة الرسم غير الضرورية
    private int _lastMessageCount = 0;
    private Guid _lastMessageId = Guid.Empty;

    protected override async Task OnInitializedAsync()
    {
        var userId = await CurrentUser.GetUserIdAsync();
        NotificationManager.SetCurrentPage("chat", RoomId, userId);
        VM.Changed += OnVmChanged;
        VM.MessageReceived += OnMessageReceivedAsync;

        Realtime.GroupRenamed += HandleGroupRenamedRealtime;
        Realtime.MemberAdded += (rid, uid, name) => InvokeAsync(async () =>
        {
            if (rid == RoomId)
            {
                await VM.RefreshRoomStateAsync(rid);
                StateHasChanged();
            }
        });
        Realtime.MemberRemoved += (rid, uid, name) => InvokeAsync(async () =>
        {
            if (rid == RoomId)
            {
                await VM.RefreshRoomStateAsync(rid);
                StateHasChanged();
            }
        });

        await VM.InitializeAsync(RoomId);
        _lastMessageCount = VM.Messages.Count;
        if (VM.Messages.Count > 0)
        {
            _lastMessageId = VM.Messages[^1].Id;
        }
    }

    private async void HandleGroupRenamedRealtime(Guid rid, string name)
    {
        if (rid == RoomId)
        {
            await InvokeAsync(async () =>
            {
                await VM.RefreshRoomStateAsync(rid);
                await RoomsVM.RefreshRoomStatusesAsync();
                StateHasChanged();
            });
        }
    }

    #region Group Actions

    private async Task HandleRenameFromDrawer(string newName)
    {
        if (string.IsNullOrWhiteSpace(newName) || newName == VM.Room?.Name) return;
        try
        {
            _membersOpen = false;
            ShowToast("Updating...");
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10));
            await GroupsApi.UpdateGroupAsync(RoomId, newName, cts.Token);
            await Realtime.GroupRenamedAsync(RoomId, newName);
            ShowToast("Group renamed!");
        }
        catch (Exception ex) { ShowToast($"Error: {ex.Message}"); }
    }

    private async Task HandleAddMemberFromDrawer(Guid userId)
    {
        try
        {
            await GroupsApi.AddMemberAsync(RoomId, userId);
            ShowToast("Adding member...");
            _membersOpen = false;
            await VM.RefreshRoomStateAsync(RoomId);
        }
        catch (Exception ex) { ShowToast($"Error: {ex.Message}"); }
    }

    private async Task HandleToggleAdmin(Guid userId)
    {
        try
        {
            await GroupsApi.PromoteAdminAsync(RoomId, userId);
            ShowToast("Permissions updated!");
            await VM.RefreshRoomStateAsync(RoomId);
        }
        catch (Exception ex) { ShowToast(ex.Message); }
    }

    private async Task HandleTransferOwner(Guid userId)
    {
        try
        {
            await GroupsApi.TransferOwnerAsync(RoomId, userId);
            ShowToast("Ownership transferred!");
            _membersOpen = false;
            await VM.RefreshRoomStateAsync(RoomId);
        }
        catch (Exception ex) { ShowToast(ex.Message); }
    }

    private async Task HandleDeleteGroup()
    {
        try
        {
            await GroupsApi.DeleteGroupAsync(RoomId);
            Nav.NavigateTo("/rooms");
        }
        catch (Exception ex) { ShowToast(ex.Message); }
    }

    private async Task HandleLeaveFromDrawer()
    {
        try
        {
            await GroupsApi.LeaveGroupAsync(RoomId);
            Nav.NavigateTo("/rooms");
        }
        catch (Exception ex) { ShowToast(ex.Message); }
    }

    #endregion

    #region Helper Methods & Lifecycle

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(currentMessage)) return;
        await HandleSendMessage(currentMessage.Trim());
        currentMessage = string.Empty;
        await ScrollToBottom();
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
            return;
        }
        await NotifyTyping();
    }

    private async Task HandleSendMessage(string text)
    {
        Guid? replyTo = ReplyCtx.MessageId != Guid.Empty ? ReplyCtx.MessageId : null;
        ReplyInfoModel? replySnapshot = null;

        if (replyTo.HasValue)
        {
            replySnapshot = new ReplyInfoModel
            {
                MessageId = ReplyCtx.MessageId,
                SenderName = ReplyCtx.SenderName,
                ContentPreview = ReplyCtx.ContentPreview,
                CreatedAt = ReplyCtx.CreatedAt,
                IsDeleted = false
            };

            var originalMessage = VM.Messages.FirstOrDefault(m => m.Id == ReplyCtx.MessageId);
            if (originalMessage != null) replySnapshot.SenderId = originalMessage.SenderId;
        }

        if (replyTo.HasValue)
            await VM.SendMessageWithReplyAsync(RoomId, text, replyTo, replySnapshot);
        else
            await VM.SendAsync(RoomId, text);

        await ScrollToBottom();
        ReplyCtx.Clear();
    }

    private async Task RetrySend(MessageModel msg) => await VM.SendAsync(RoomId, msg.Content);

    private Task NotifyTyping() => VM.NotifyTypingAsync(RoomId);

    private Task HandleReplyRequest(Guid messageId)
    {
        var message = VM.Messages.FirstOrDefault(m => m.Id == messageId);
        if (message == null) return Task.CompletedTask;

        ReplyCtx.MessageId = message.Id;
        ReplyCtx.SenderName = message.SenderId == VM.CurrentUserId ? "You" : VM.GetSenderName(message.SenderId);
        ReplyCtx.ContentPreview = message.Content.Length > 60 ? message.Content[..60] + "…" : message.Content;
        ReplyCtx.CreatedAt = message.CreatedAt;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private void StartEdit(MessageModel msg)
    {
        _editingMessage = msg;
        currentMessage = msg.Content;
        _ = JS.InvokeVoidAsync("eval", "document.querySelector('.composer-input').focus()");
    }

    private async Task HandleDeleteRequested(MessageModel msg)
    {
        if (msg.SenderId == VM.CurrentUserId)
        {
            if (await JS.InvokeAsync<bool>("confirm", "Delete for everyone?"))
                await VM.DeleteMessageAsync(msg.Id, true);
        }
        else
            await VM.DeleteMessageAsync(msg.Id, false);
    }

    private Task ToggleReaction(Guid messageId)
    {
        OpenReactionMessageId = OpenReactionMessageId == messageId ? null : messageId;
        return Task.CompletedTask;
    }

    private async Task OpenReactionDetails(Guid messageId)
    {
        _reactionMessageId = messageId;
        _reactionModalOpen = true;
        _reactionDetails = await VM.GetMessageReactionsDetailsAsync(messageId);
        StateHasChanged();
    }

    private async Task RemoveMyReaction(Guid userId)
    {
        if (_reactionMessageId == Guid.Empty) return;
        var message = VM.Messages.FirstOrDefault(m => m.Id == _reactionMessageId);
        if (message?.Reactions?.CurrentUserReactionType == null) return;
        await VM.AddReactionAsync(_reactionMessageId, message.Reactions.CurrentUserReactionType.Value);
        _reactionModalOpen = false;
    }

    private void CloseReactionDetails()
    {
        _reactionModalOpen = false;
        _reactionDetails = null;
        _reactionMessageId = Guid.Empty;
    }

    private async Task OnReaction(ReactionPayload payload) => await VM.AddReactionAsync(payload.MessageId, payload.Type);

    // ✅ الحل النهائي: تحديث الرسالة الموجودة بدل إضافة duplicate
    // في Chat.razor - داخل @code
    private async Task OnMessageReceivedAsync(MessageModel message)
    {
        // ✅ ابحث عن الرسالة لو موجودة
        var existingMessage = VM.Messages.FirstOrDefault(m => m.Id == message.Id);
        if (existingMessage != null)
        {
            // ✅ حدث الخصائص مباشرة في الـ ObservableCollection
            var needsUpdate = false;

            if (existingMessage.ReplyInfo?.ContentPreview != message.ReplyInfo?.ContentPreview)
            {
                existingMessage.ReplyInfo = message.ReplyInfo;
                needsUpdate = true;
            }

            if (existingMessage.Status != message.Status)
            {
                existingMessage.Status = message.Status;
                needsUpdate = true;
            }

            if (existingMessage.PersonalStatus != message.PersonalStatus)
            {
                existingMessage.PersonalStatus = message.PersonalStatus;
                needsUpdate = true;
            }

            if (existingMessage.DeliveredCount != message.DeliveredCount)
            {
                existingMessage.DeliveredCount = message.DeliveredCount;
                needsUpdate = true;
            }

            if (existingMessage.ReadCount != message.ReadCount)
            {
                existingMessage.ReadCount = message.ReadCount;
                needsUpdate = true;
            }

            if (existingMessage.TotalRecipients != message.TotalRecipients)
            {
                existingMessage.TotalRecipients = message.TotalRecipients;
                needsUpdate = true;
            }

            if (needsUpdate)
            {
                // ✅ ObservableCollection会自动 notify UI
                await InvokeAsync(StateHasChanged);
            }
            return;
        }

        // ✅ رسالة جديدة - أضفها للمجموعة
        VM.Messages.Add(message);

        // ✅ معالجة Reply Info
        if (message.ReplyToMessageId.HasValue && message.ReplyInfo == null)
        {
            var originalMessage = VM.Messages.FirstOrDefault(m => m.Id == message.ReplyToMessageId.Value);
            if (originalMessage != null)
            {
                message.ReplyInfo = new ReplyInfoModel
                {
                    MessageId = originalMessage.Id,
                    SenderId = originalMessage.SenderId,
                    SenderName = VM.GetSenderName(originalMessage.SenderId),
                    ContentPreview = originalMessage.Content.Length > 60
                        ? originalMessage.Content[..60] + "…"
                        : originalMessage.Content,
                    CreatedAt = originalMessage.CreatedAt,
                    IsDeleted = originalMessage.IsDeleted
                };
            }
        }

        // ✅ Mark as read فوراً لو مش منك
        if (message.SenderId != VM.CurrentUserId)
        {
            _ = VM.MarkRoomReadAsync(RoomId, message.Id);
        }

        await ScrollToBottom();
    }
    private Task HandleReachedBottom(Guid lastMessageId)
    {
        if (lastMessageId == Guid.Empty || lastMessageId == _lastSentReadId) return Task.CompletedTask;

        _readCts?.Cancel();
        _readCts?.Dispose();
        _readCts = new CancellationTokenSource();
        var ct = _readCts.Token;

        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(400, ct);
                if (ct.IsCancellationRequested) return;

                _lastSentReadId = lastMessageId;
                await VM.MarkRoomReadAsync(RoomId, lastMessageId);
                await InvokeAsync(() => RoomsVM.MarkRoomAsReadLocal(RoomId, lastMessageId));
            }
            catch { }
        }, ct);

        return Task.CompletedTask;
    }

    private async Task ScrollToMessage(Guid messageId)
    {
        var elementId = $"message-{messageId}";
        await JS.InvokeVoidAsync("scrollToMessage", elementId);
        await JS.InvokeVoidAsync("highlightMessage", elementId);
    }

    private async Task ScrollToBottom() => await JS.InvokeVoidAsync("scrollToBottomSmooth", "chat-messages");

    private Task RemoveMember(Guid userId) => VM.RemoveMemberAsync(RoomId, userId);

    private Task BlockOtherUser() => VM.OtherUser == null ? Task.CompletedTask : VM.BlockUserAsync(VM.OtherUser.Id);

    private Task ToggleMute() => VM.ToggleMuteAsync(RoomId);

    private void OpenMembers() { if (VM.Room?.Type == "Group") _membersOpen = true; }

    private void CloseMembers() => _membersOpen = false;

    private Task UnblockOtherUser() => VM.OtherUser == null ? Task.CompletedTask : VM.UnblockUserAsync(VM.OtherUser.Id);

    private void ShowToast(string message)
    {
        _toastMessage = message;
        _showToast = true;
        StateHasChanged();
        _ = Task.Delay(3000).ContinueWith(_ =>
        {
            _showToast = false;
            InvokeAsync(StateHasChanged);
        });
    }

    private async void OnVmChanged()
    {
        if (_renderQueued || VM.IsSearching) return;

        // ✅ منع إعادة الرسم إذا لم يتغير عدد الرسائل أو آخر رسالة
        var currentCount = VM.Messages.Count;
        var currentLastId = currentCount > 0 ? VM.Messages[^1].Id : Guid.Empty;

        if (currentCount == _lastMessageCount && currentLastId == _lastMessageId)
        {
            return;
        }

        _lastMessageCount = currentCount;
        _lastMessageId = currentLastId;

        _renderQueued = true;
        _ = InvokeAsync(async () =>
        {
            try
            {
                await Task.Delay(50);
                StateHasChanged();
                await JS.InvokeVoidAsync("scrollToBottomSmooth", "chat-messages");
            }
            finally
            {
                _renderQueued = false;
            }
        });
    }

    public void Dispose()
    {
        VM.Changed -= OnVmChanged;
        VM.MessageReceived -= OnMessageReceivedAsync;
        Realtime.GroupRenamed -= HandleGroupRenamedRealtime;
        NotificationManager.SetCurrentPage("unknown", null, Guid.Empty);

        _readCts?.Cancel();
        _readCts?.Dispose();

        _ = Task.Run(async () => { try { await VM.DisposeAsync(); } catch { } });
        _ = Task.Run(async () =>
        {
            try
            {
                if (_chatModule != null)
                {
                    await _chatModule.InvokeVoidAsync("unregisterEscape");
                    await _chatModule.DisposeAsync();
                }
            }
            catch { }
        });

        _objRef?.Dispose();
    }

    private void OpenAttachmentsDrawer() { _attachMenuOpen = false; _attachmentsOpen = true; }

    private void CloseAttachments() => _attachmentsOpen = false;

    private void ToggleAttachMenu() => _attachMenuOpen = !_attachMenuOpen;

    private void CloseAttachMenuIfOpen()
    {
        if (_attachMenuOpen)
        {
            _attachMenuOpen = false;
            StateHasChanged();
        }
    }

    private void TriggerFileUpload()
    {
        _attachMenuOpen = false;
        _ = JS.InvokeVoidAsync("eval", "document.getElementById('attach-file-input').click()");
    }

    private async Task OnFileSelected(InputFileChangeEventArgs e)
    {
        if (RoomId == Guid.Empty) return;
        bool uploaded = false;

        foreach (var file in e.GetMultipleFiles())
        {
            const long maxBytes = 25 * 1024 * 1024;
            await using var stream = file.OpenReadStream(maxAllowedSize: maxBytes);
            await AttachmentsApi.UploadAsync(RoomId, stream, file.Name, file.ContentType);
            uploaded = true;
        }

        if (uploaded) ShowToast("File uploaded successfully!");
        StateHasChanged();
    }

    private sealed class ChatPageInterop
    {
        private readonly Chat _page;
        public ChatPageInterop(Chat page) => _page = page;

        [JSInvokable]
        public Task OnGlobalEscape()
        {
            var changed = false;
            if (_page._attachmentsOpen) { _page.CloseAttachments(); changed = true; }
            if (_page._membersOpen) { _page.CloseMembers(); changed = true; }
            if (_page._attachMenuOpen) { _page._attachMenuOpen = false; changed = true; }
            return changed ? _page.InvokeAsync(_page.StateHasChanged) : Task.CompletedTask;
        }
    }
    #endregion
}