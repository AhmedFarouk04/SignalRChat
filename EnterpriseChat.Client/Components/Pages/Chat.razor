@page "/chat/{RoomId:guid}"
@attribute [Microsoft.AspNetCore.Authorization.Authorize]
@using EnterpriseChat.Client.Components.Reaction
@using EnterpriseChat.Client.Services.Realtime
@using EnterpriseChat.Client.ViewModels
@using EnterpriseChat.Client.Models
@using EnterpriseChat.Domain.Enums
@using Microsoft.JSInterop
@using EnterpriseChat.Application.DTOs
@using EnterpriseChat.Client.Services.Http
@using EnterpriseChat.Client.Services.Attachments
@using Microsoft.AspNetCore.Components.Forms
@inject GroupsApi GroupsApi
@inject UsersApi UsersApi
@inject ChatViewModel VM
@inject NavigationManager Nav
@inject IJSRuntime JS
@inject RoomsViewModel RoomsVM
@inject EnterpriseChat.Client.Models.ReplyContext ReplyCtx
@inject AttachmentsApi AttachmentsApi
@implements IDisposable
@inject IChatRealtimeClient Realtime

<div class="chat-page">
    @if (_showToast)
    {
        <div class="custom-toast">
            <span>@_toastMessage</span>
        </div>
    }

    <TopBar Room="@VM.Room"
            VM="@VM"
            OnScrollToMessage="ScrollToMessage"
            MembersCount="@(VM.GroupMembers?.Members.Count ?? 0)"
            OnlineCount="@VM.OnlineUsers.Count"
            OtherUser="@VM.OtherUser"
            IsMuted="@VM.IsMuted"
            IsBlockedByMe="@VM.IsBlockedByMe"
            OnMuteToggle="ToggleMute"
            OnBlock="BlockOtherUser"
            OnUnblock="UnblockOtherUser"
            OnMembers="OpenMembers" />

    @if (VM.UiError != null)
    {
        <div class="chat-error">@VM.UiError</div>
    }
    else if (VM.Room == null)
    {
        <div class="chat-error">This room no longer exists.</div>
    }
    else if (VM.IsRemoved)
    {
        <div class="chat-error">
            You were removed from this group.
            <button class="mini-btn" @onclick="@(() => Nav.NavigateTo("/rooms"))">Back to rooms</button>
        </div>
    }
    else
    {
        <div class="chat-body">
            @if (VM.IsDisconnected)
            {
                <div class="connection-banner">Reconnecting…</div>
            }

            <div class="chat-messages" id="chat-messages">
                <MessageList Messages="@OrderedMessages"
                             CurrentUserId="@VM.CurrentUserId"
                             Room="@VM.Room"
                             GroupMembers="@(VM.GroupMembers?.Members ?? new())"
                             OnRetry="RetrySend"
                             OnReachedBottom="HandleReachedBottom"
                             OnReaction="OnReaction"
                             OnReplyRequested="HandleReplyRequest"
                             OnScrollToMessage="ScrollToMessage"
                             OnOpenReactionDetails="OpenReactionDetails"
                             OpenReactionMessageId="@OpenReactionMessageId"
                             OnToggleReaction="ToggleReaction"
                             OnEditRequested="StartEdit"
                             OnDeleteRequested="HandleDeleteRequested" />

                <div id="messages-end"></div>

                <TypingIndicator TypingUsers="@VM.TypingUsers" />

                @if (_reactionModalOpen && _reactionDetails != null)
                {
                    <ReactionDetailsModal Data="_reactionDetails"
                                          OnRemoveMyReaction="RemoveMyReaction"
                                          OnClose="CloseReactionDetails" />
                }
            </div>

            @if (_attachmentsOpen)
            {
                <div class="drawer-backdrop" @onclick="CloseAttachments"></div>
                <aside class="drawer" role="dialog" aria-modal="true" aria-label="Attachments drawer" tabindex="0">
                    <div class="drawer-header">
                        <div>
                            <div class="drawer-name">Attachments</div>
                            <div class="drawer-sub">Room files</div>
                        </div>
                        <button class="icon-btn" title="Close" @onclick="CloseAttachments" autofocus>✕</button>
                    </div>
                    <div class="drawer-list">
                        <ChatAttachments RoomId="RoomId" />
                    </div>
                </aside>
            }

            <div class="chat-input" @onclick="CloseAttachMenuIfOpen">
                @if (VM.IsOtherDeleted)
                {
                    <div class="blocked-banner">This user is no longer available.</div>
                }
                else if (VM.IsBlockedByMe)
                {
                    <div class="blocked-banner">You blocked this user. Unblock to send messages.</div>
                }
                else
                {
                    <div class="composer">
                        @if (ReplyCtx.MessageId != Guid.Empty)
                        {
                            <div class="reply-context">
                                <div class="reply-header">
                                    <span>Replying to @ReplyCtx.SenderName</span>
                                    <button class="cancel-reply" @onclick="ReplyCtx.Clear" type="button">✕</button>
                                </div>
                                <div class="reply-preview-text">@ReplyCtx.ContentPreview</div>
                            </div>
                        }
                        <div class="composer-box">
                            <button type="button" class="attach-btn" @onclick="ToggleAttachMenu" @onclick:stopPropagation="true" title="Attach">
                                📎
                            </button>
                            @if (_attachMenuOpen)
                            {
                                <div class="attach-popup" @onclick:stopPropagation="true">
                                    <button class="popup-item" @onclick="TriggerFileUpload">📄 Upload file</button>
                                    <button class="popup-item" @onclick="OpenAttachmentsDrawer">🗂️ View attachments</button>
                                </div>
                            }
                            <InputFile OnChange="OnFileSelected" multiple id="attach-file-input" style="display:none;" />
                            <textarea class="composer-input" @ref="inputRef"
                                      placeholder="@(ReplyCtx.MessageId != Guid.Empty ? "Type your reply…" : "Message…")"
                                      @bind="currentMessage" @bind:event="oninput" @onkeydown="OnKeyDown"></textarea>
                            <button class="composer-send" type="button"
                                    disabled="@string.IsNullOrWhiteSpace(currentMessage.Trim())" @onclick="SendMessage">
                                Send
                            </button>
                        </div>
                    </div>
                }
            </div>

            @if (_membersOpen && VM.Room?.Type == "Group")
            {
                <MembersDrawer IsOpen="_membersOpen"
                               Members="@VM.GetAllMembersForDrawer()"
                               OwnerId="@(VM.GroupMembers?.OwnerId ?? Guid.Empty)"
                               CurrentUserId="@VM.CurrentUserId"
                               GroupName="@VM.Room.Name"
                               CanManageMembers="@(VM.GroupMembers?.OwnerId == VM.CurrentUserId)"
                               OnRemove="RemoveMember"
                               OnAdd="HandleAddMemberFromDrawer"
                               OnRename="HandleRenameFromDrawer"
                               OnToggleAdmin="HandleToggleAdmin"
                               OnTransferOwner="HandleTransferOwner"
                               OnDelete="HandleDeleteGroup"
                               OnLeave="HandleLeaveFromDrawer"
                               OnClose="CloseMembers" />
            }

            @if (VM.IsSelectionMode)
            {
                <div class="forward-action-bar">
                    <div class="selection-info">
                        <button class="icon-btn close-btn" @onclick="() => VM.IsSelectionMode = false">✕</button>
                        <span>@VM.SelectedMessageIds.Count Selected</span>
                    </div>
                    <button class="forward-submit-btn @(VM.SelectedMessageIds.Any() ? "active" : "")"
                            disabled="@(!VM.SelectedMessageIds.Any())" @onclick="() => VM.IsForwardModalOpen = true">
                        Forward ➔
                    </button>
                </div>
            }
        </div>
    }

    <PinDurationModal IsOpen="VM.IsPinModalOpen" OnCancel="() => VM.IsPinModalOpen = false" OnConfirm="VM.ConfirmPinAsync" />
    <ForwardModal IsOpen="VM.IsForwardModalOpen" OnClose="() => VM.IsForwardModalOpen = false" />
</div>

@code {
    [Parameter] public Guid RoomId { get; set; }

    private bool _membersOpen;
    private bool _attachmentsOpen;
    private bool _attachMenuOpen;
    private bool _renderQueued;
    private string currentMessage = string.Empty;
    private ElementReference inputRef;
    private string _toastMessage = string.Empty;
    private bool _showToast = false;
    private DotNetObjectReference<ChatPageInterop>? _objRef;
    private bool _escapeRegistered;
    private IJSObjectReference? _chatModule;
    private CancellationTokenSource? _readCts;
    private Guid _lastSentReadId = Guid.Empty;
    private MessageReactionsDetailsDto? _reactionDetails;
    private bool _reactionModalOpen;
    private Guid _reactionMessageId;
    private Guid? OpenReactionMessageId;
    private MessageModel? _editingMessage;

    protected override async Task OnInitializedAsync()
    {
        VM.Changed += OnVmChanged;
        VM.MessageReceived += OnMessageReceivedAsync;

        // ✅ 1. Real-time: Rename Listener
        Realtime.GroupRenamed += HandleGroupRenamedRealtime;

        // ✅ 2. Real-time: Membership Listener
        Realtime.MemberAdded += (rid, uid, name) => InvokeAsync(async () => { if (rid == RoomId) { await VM.RefreshRoomStateAsync(rid); StateHasChanged(); } });
        Realtime.MemberRemoved += (rid, uid, name) => InvokeAsync(async () => { if (rid == RoomId) { await VM.RefreshRoomStateAsync(rid); StateHasChanged(); } });

        await VM.InitializeAsync(RoomId);
    }

    private async void HandleGroupRenamedRealtime(Guid rid, string name)
    {
        if (rid == RoomId)
        {
            await InvokeAsync(async () =>
            {
                await VM.RefreshRoomStateAsync(rid);
                await RoomsVM.RefreshRoomStatusesAsync(); // تحديث الـ Sidebar
                StateHasChanged();
            });
        }
    }

    #region Group Actions (Optimized for No Deadlock)

    private async Task HandleRenameFromDrawer(string newName)
    {
        if (string.IsNullOrWhiteSpace(newName) || newName == VM.Room?.Name) return;
        try
        {
            _membersOpen = false; // UX: إغلاق فوري
            ShowToast("Updating...");
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10));
            await GroupsApi.UpdateGroupAsync(RoomId, newName, cts.Token);

            // ✅ تبليغ الـ Hub عشان التحديث يوصل لكل الناس فوراً
            await Realtime.GroupRenamedAsync(RoomId, newName);
            ShowToast("Group renamed!");
        }
        catch (Exception ex) { ShowToast($"Error: {ex.Message}"); }
    }

    private async Task HandleAddMemberFromDrawer(Guid userId)
    {
        try
        {
            await GroupsApi.AddMemberAsync(RoomId, userId);
            ShowToast("Adding member...");
            _membersOpen = false;
            await VM.RefreshRoomStateAsync(RoomId);
        }
        catch (Exception ex) { ShowToast($"Error: {ex.Message}"); }
    }

    private async Task HandleToggleAdmin(Guid userId)
    {
        try
        {
            await GroupsApi.PromoteAdminAsync(RoomId, userId);
            ShowToast("Permissions updated!");
            await VM.RefreshRoomStateAsync(RoomId);
        }
        catch (Exception ex) { ShowToast(ex.Message); }
    }

    private async Task HandleTransferOwner(Guid userId)
    {
        try
        {
            await GroupsApi.TransferOwnerAsync(RoomId, userId);
            ShowToast("Ownership transferred!");
            _membersOpen = false;
            await VM.RefreshRoomStateAsync(RoomId);
        }
        catch (Exception ex) { ShowToast(ex.Message); }
    }

    private async Task HandleDeleteGroup()
    {
        try
        {
            await GroupsApi.DeleteGroupAsync(RoomId);
            Nav.NavigateTo("/rooms");
        }
        catch (Exception ex) { ShowToast(ex.Message); }
    }

    private async Task HandleLeaveFromDrawer()
    {
        try
        {
            await GroupsApi.LeaveGroupAsync(RoomId);
            Nav.NavigateTo("/rooms");
        }
        catch (Exception ex) { ShowToast(ex.Message); }
    }

    #endregion

    #region Helper Methods & Lifecycle

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(currentMessage)) return;
        await HandleSendMessage(currentMessage.Trim());
        currentMessage = string.Empty;
        await ScrollToBottom();
    }

    private async Task OnKeyDown(KeyboardEventArgs e) { if (e.Key == "Enter" && !e.ShiftKey) { await SendMessage(); return; } await NotifyTyping(); }

    private async Task HandleSendMessage(string text)
    {
        Guid? replyTo = ReplyCtx.MessageId != Guid.Empty ? ReplyCtx.MessageId : null;
        ReplyInfoModel? replySnapshot = null;
        if (replyTo.HasValue)
        {
            replySnapshot = new ReplyInfoModel { MessageId = ReplyCtx.MessageId, SenderName = ReplyCtx.SenderName, ContentPreview = ReplyCtx.ContentPreview, CreatedAt = ReplyCtx.CreatedAt, IsDeleted = false };
            var originalMessage = VM.Messages.FirstOrDefault(m => m.Id == ReplyCtx.MessageId);
            if (originalMessage != null) replySnapshot.SenderId = originalMessage.SenderId;
        }
        if (replyTo.HasValue) await VM.SendMessageWithReplyAsync(RoomId, text, replyTo, replySnapshot);
        else await VM.SendAsync(RoomId, text);
        await ScrollToBottom();
        ReplyCtx.Clear();
    }

    private async Task RetrySend(MessageModel msg) => await VM.SendAsync(RoomId, msg.Content);
    private Task NotifyTyping() => VM.NotifyTypingAsync(RoomId);
    private Task HandleReplyRequest(Guid messageId)
    {
        var message = VM.Messages.FirstOrDefault(m => m.Id == messageId);
        if (message == null) return Task.CompletedTask;
        ReplyCtx.MessageId = message.Id;
        ReplyCtx.SenderName = message.SenderId == VM.CurrentUserId ? "You" : VM.GetSenderName(message.SenderId);
        ReplyCtx.ContentPreview = message.Content.Length > 60 ? message.Content[..60] + "…" : message.Content;
        ReplyCtx.CreatedAt = message.CreatedAt;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private void StartEdit(MessageModel msg) { _editingMessage = msg; currentMessage = msg.Content; _ = JS.InvokeVoidAsync("eval", "document.querySelector('.composer-input').focus()"); }
    private async Task HandleDeleteRequested(MessageModel msg)
    {
        if (msg.SenderId == VM.CurrentUserId)
        {
            if (await JS.InvokeAsync<bool>("confirm", "Delete for everyone?")) await VM.DeleteMessageAsync(msg.Id, true);
        }
        else await VM.DeleteMessageAsync(msg.Id, false);
    }

    private Task ToggleReaction(Guid messageId) { OpenReactionMessageId = OpenReactionMessageId == messageId ? null : messageId; return Task.CompletedTask; }
    private async Task OpenReactionDetails(Guid messageId) { _reactionMessageId = messageId; _reactionModalOpen = true; _reactionDetails = await VM.GetMessageReactionsDetailsAsync(messageId); StateHasChanged(); }
    private async Task RemoveMyReaction(Guid userId)
    {
        if (_reactionMessageId == Guid.Empty) return;
        var message = VM.Messages.FirstOrDefault(m => m.Id == _reactionMessageId);
        if (message?.Reactions?.CurrentUserReactionType == null) return;
        await VM.AddReactionAsync(_reactionMessageId, message.Reactions.CurrentUserReactionType.Value);
        _reactionModalOpen = false;
    }
    private void CloseReactionDetails() { _reactionModalOpen = false; _reactionDetails = null; _reactionMessageId = Guid.Empty; }
    private async Task OnReaction(ReactionPayload payload) => await VM.AddReactionAsync(payload.MessageId, payload.Type);

    private async Task OnMessageReceivedAsync(MessageModel message)
    {
        var existingMessage = VM.Messages.FirstOrDefault(m => m.Id == message.Id);
        if (existingMessage != null) { existingMessage.ReplyInfo = message.ReplyInfo; existingMessage.Status = message.Status; return; }
        if (message.ReplyToMessageId.HasValue && message.ReplyInfo == null)
        {
            var originalMessage = VM.Messages.FirstOrDefault(m => m.Id == message.ReplyToMessageId.Value);
            if (originalMessage != null) message.ReplyInfo = new ReplyInfoModel { MessageId = originalMessage.Id, SenderId = originalMessage.SenderId, SenderName = VM.GetSenderName(originalMessage.SenderId), ContentPreview = originalMessage.Content.Length > 60 ? originalMessage.Content[..60] + "…" : originalMessage.Content, CreatedAt = originalMessage.CreatedAt, IsDeleted = originalMessage.IsDeleted };
        }
        await InvokeAsync(StateHasChanged);
        await ScrollToBottom();
    }

    private Task HandleReachedBottom(Guid lastMessageId)
    {
        if (lastMessageId == Guid.Empty || lastMessageId == _lastSentReadId) return Task.CompletedTask;
        _readCts?.Cancel(); _readCts?.Dispose(); _readCts = new CancellationTokenSource();
        var ct = _readCts.Token;
        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(400, ct); if (ct.IsCancellationRequested) return;
                _lastSentReadId = lastMessageId;
                await VM.MarkRoomReadAsync(RoomId, lastMessageId);
                await InvokeAsync(() => RoomsVM.MarkRoomAsReadLocal(RoomId, lastMessageId));
            }
            catch { }
        }, ct);
        return Task.CompletedTask;
    }

    private async Task ScrollToMessage(Guid messageId) { var elementId = $"message-{messageId}"; await JS.InvokeVoidAsync("scrollToMessage", elementId); await JS.InvokeVoidAsync("highlightMessage", elementId); }
    private async Task ScrollToBottom() => await JS.InvokeVoidAsync("scrollToBottomSmooth", "chat-messages");
    private Task RemoveMember(Guid userId) => VM.RemoveMemberAsync(RoomId, userId);
    private Task BlockOtherUser() => VM.OtherUser == null ? Task.CompletedTask : VM.BlockUserAsync(VM.OtherUser.Id);
    private Task ToggleMute() => VM.ToggleMuteAsync(RoomId);
    private void OpenMembers() { if (VM.Room?.Type == "Group") _membersOpen = true; }
    private void CloseMembers() => _membersOpen = false;
    private Task UnblockOtherUser() => VM.OtherUser == null ? Task.CompletedTask : VM.UnblockUserAsync(VM.OtherUser.Id);

    private void ShowToast(string message) { _toastMessage = message; _showToast = true; StateHasChanged(); _ = Task.Delay(3000).ContinueWith(_ => { _showToast = false; InvokeAsync(StateHasChanged); }); }
    private async void OnVmChanged()
    {
        if (_renderQueued || VM.IsSearching) return;
        _renderQueued = true;
        _ = InvokeAsync(async () => { try { await Task.Delay(50); StateHasChanged(); await JS.InvokeVoidAsync("scrollToBottomSmooth", "chat-messages"); } finally { _renderQueued = false; } });
    }

    public void Dispose()
    {
        VM.Changed -= OnVmChanged; VM.MessageReceived -= OnMessageReceivedAsync;
        Realtime.GroupRenamed -= HandleGroupRenamedRealtime;
        _readCts?.Cancel(); _readCts?.Dispose();
        _ = Task.Run(async () => { try { await VM.DisposeAsync(); } catch { } });
        _ = Task.Run(async () => { try { if (_chatModule != null) { await _chatModule.InvokeVoidAsync("unregisterEscape"); await _chatModule.DisposeAsync(); } } catch { } });
        _objRef?.Dispose();
    }

    private void OpenAttachmentsDrawer() { _attachMenuOpen = false; _attachmentsOpen = true; }
    private void CloseAttachments() => _attachmentsOpen = false;
    private void ToggleAttachMenu() => _attachMenuOpen = !_attachMenuOpen;
    private void CloseAttachMenuIfOpen() { if (_attachMenuOpen) { _attachMenuOpen = false; StateHasChanged(); } }
    private void TriggerFileUpload() { _attachMenuOpen = false; _ = JS.InvokeVoidAsync("eval", "document.getElementById('attach-file-input').click()"); }
    private async Task OnFileSelected(InputFileChangeEventArgs e)
    {
        if (RoomId == Guid.Empty) return;
        bool uploaded = false;
        foreach (var file in e.GetMultipleFiles())
        {
            const long maxBytes = 25 * 1024 * 1024;
            await using var stream = file.OpenReadStream(maxAllowedSize: maxBytes);
            await AttachmentsApi.UploadAsync(RoomId, stream, file.Name, file.ContentType);
            uploaded = true;
        }
        if (uploaded) ShowToast("File uploaded successfully!");
        StateHasChanged();
    }

    private IReadOnlyList<MessageModel> OrderedMessages => VM.Messages?.OrderBy(m => m.CreatedAt).ToList() ?? new List<MessageModel>();

    private sealed class ChatPageInterop
    {
        private readonly Chat _page;
        public ChatPageInterop(Chat page) => _page = page;
        [JSInvokable]
        public Task OnGlobalEscape()
        {
            var changed = false;
            if (_page._attachmentsOpen) { _page.CloseAttachments(); changed = true; }
            if (_page._membersOpen) { _page.CloseMembers(); changed = true; }
            if (_page._attachMenuOpen) { _page._attachMenuOpen = false; changed = true; }
            return changed ? _page.InvokeAsync(_page.StateHasChanged) : Task.CompletedTask;
        }
    }
    #endregion
}