@page "/chat/{RoomId:guid}"
@attribute [Microsoft.AspNetCore.Authorization.Authorize]
@using EnterpriseChat.Client.Authentication.Abstractions
@using EnterpriseChat.Client.Components.Reaction
@using EnterpriseChat.Client.Services.Realtime
@using EnterpriseChat.Client.Services.Ui
@using EnterpriseChat.Client.ViewModels
@using EnterpriseChat.Client.Models
@using EnterpriseChat.Domain.Enums
@using TypingIndicator = EnterpriseChat.Client.Components.Pages.TypingIndicator

@using Microsoft.JSInterop
@using EnterpriseChat.Application.DTOs
@using EnterpriseChat.Client.Services.Http
@using EnterpriseChat.Client.Services.Attachments
@using Microsoft.AspNetCore.Components.Forms
@inject GroupsApi GroupsApi
@inject UsersApi UsersApi
@inject ChatViewModel VM
@inject NavigationManager Nav
@inject IJSRuntime JS
@inject RoomsViewModel RoomsVM
@inject EnterpriseChat.Client.Models.ReplyContext ReplyCtx
@inject AttachmentsApi AttachmentsApi
@using ClientMessageStatus = EnterpriseChat.Client.Models.MessageStatus

@implements IDisposable
@inject NotificationManager NotificationManager
@inject ICurrentUser CurrentUser
@inject IChatRealtimeClient Realtime

<div class="chat-page">
    @if (_showToast)
    {
        <div class="custom-toast">
            <span>@_toastMessage</span>
        </div>
    }

    <TopBar Room="@VM.Room"
            VM="@VM"
            OnScrollToMessage="ScrollToMessage"
            MembersCount="@(VM.GroupMembers?.Members.Count ?? 0)"
            OnlineCount="@VM.OnlineUsers.Count"
            OtherUser="@VM.OtherUser"
            IsMuted="@VM.IsMuted"
            IsBlockedByMe="@VM.IsBlockedByMe"
            OnMuteToggle="ToggleMute"
            OnBlock="BlockOtherUser"
            OnUnblock="UnblockOtherUser"
            OnMembers="OpenMembers" />

    @if (VM.UiError != null)
    {
        <div class="chat-error">@VM.UiError</div>
    }
    else if (VM.Room == null)
    {
        <div class="chat-error">This room no longer exists.</div>
    }
    else if (VM.IsRemoved)
    {
        <div class="chat-error">
            You were removed from this group.
            <button class="mini-btn" @onclick="@(() => Nav.NavigateTo("/rooms"))">Back to rooms</button>
        </div>
    }
    else
    {
        <div class="chat-body">
            @if (VM.IsDisconnected)
            {
                <div class="connection-banner">Reconnecting…</div>
            }

            <div class="chat-messages" id="chat-messages">
                @* ✅ استخدام Virtualize لتحسين الأداء ومنع إعادة إنشاء كل الرسائل *@
                <MessageList Messages="@VM.Messages"
                             CurrentUserId="@VM.CurrentUserId"
                             Room="@VM.Room"
                             GroupMembers="@(VM.GroupMembers?.Members ?? new())"
                             OnRetry="RetrySend"
                             OnReachedBottom="HandleReachedBottom"
                             OnReaction="OnReaction"
                             OnReplyRequested="HandleReplyRequest"
                             OnScrollToMessage="ScrollToMessage"
                             OnOpenReactionDetails="OpenReactionDetails"
                             OpenReactionMessageId="@OpenReactionMessageId"
                             OnToggleReaction="ToggleReaction"
                             OnEditRequested="StartEdit"
                             OnDeleteRequested="HandleDeleteRequested" />

                <div id="messages-end"></div>

                
               
                @if (_reactionModalOpen && _reactionDetails != null)
                {
                    <ReactionDetailsModal Data="_reactionDetails"
                                          OnRemoveMyReaction="RemoveMyReaction"
                                          OnClose="CloseReactionDetails" />
                }
            </div>
            <div class="typing-indicator-container" style="overflow: hidden;">
                <TypingIndicator RoomId="@RoomId"
                                 IsGroup="@(VM.Room?.Type == "Group")"
                                 AllUsers="@VM.GetAllUsers()" />
            </div>
            @{
                var allUsers = new List<UserModel>();
                if (VM.GroupMembers?.Members != null)
                {
                    allUsers.AddRange(VM.GroupMembers.Members);
                }
                if (VM.OtherUser != null && !allUsers.Any(u => u.Id == VM.OtherUser.Id))
                {
                    allUsers.Add(VM.OtherUser);
                }
            }
            @if (_attachmentsOpen)
            {
                <div class="drawer-backdrop" @onclick="CloseAttachments"></div>
                <aside class="drawer" role="dialog" aria-modal="true" aria-label="Attachments drawer" tabindex="0">
                    <div class="drawer-header">
                        <div>
                            <div class="drawer-name">Attachments</div>
                            <div class="drawer-sub">Room files</div>
                        </div>
                        <button class="icon-btn" title="Close" @onclick="CloseAttachments" autofocus>✕</button>
                    </div>
                    <div class="drawer-list">
                        <ChatAttachments RoomId="RoomId" />
                    </div>
                </aside>
            }

            <div class="chat-input" @onclick="CloseAttachMenuIfOpen">
                @if (VM.IsOtherDeleted)
                {
                    <div class="blocked-banner">This user is no longer available.</div>
                }
                else if (VM.IsBlockedByMe)
                {
                    <div class="blocked-banner">You blocked this user. Unblock to send messages.</div>
                }
                else
                {
                    <div class="composer">
                        @if (ReplyCtx.MessageId != Guid.Empty)
                        {
                            <div class="reply-context">
                                <div class="reply-header">
                                    <span>Replying to @ReplyCtx.SenderName</span>
                                    <button class="cancel-reply" @onclick="ReplyCtx.Clear" type="button">✕</button>
                                </div>
                                <div class="reply-preview-text">@ReplyCtx.ContentPreview</div>
                            </div>
                        }
                        <div class="composer-box">
                            <button type="button" class="attach-btn" @onclick="ToggleAttachMenu" @onclick:stopPropagation="true" title="Attach">
                                📎
                            </button>
                            @if (_attachMenuOpen)
                            {
                                <div class="attach-popup" @onclick:stopPropagation="true">
                                    <button class="popup-item" @onclick="TriggerFileUpload">📄 Upload file</button>
                                    <button class="popup-item" @onclick="OpenAttachmentsDrawer">🗂️ View attachments</button>
                                </div>
                            }
                            <InputFile OnChange="OnFileSelected" multiple id="attach-file-input" style="display:none;" />
                            <textarea class="composer-input" @ref="inputRef"
                                      placeholder="@(ReplyCtx.MessageId != Guid.Empty ? "Type your reply…" : "Message…")"
                                      @bind="currentMessage" @bind:event="oninput" @onkeydown="OnKeyDown"></textarea>
                            <button class="composer-send" type="button"
                                    disabled="@string.IsNullOrWhiteSpace(currentMessage.Trim())" @onclick="SendMessage">
                                Send
                            </button>
                        </div>
                    </div>
                }
            </div>

            @if (_membersOpen && VM.Room?.Type == "Group")
            {
                <MembersDrawer IsOpen="_membersOpen"
                               Members="@VM.GetAllMembersForDrawer()"
                               OwnerId="@(VM.GroupMembers?.OwnerId ?? Guid.Empty)"
                               CurrentUserId="@VM.CurrentUserId"
                               GroupName="@VM.Room.Name"
                               CanManageMembers="@(VM.GroupMembers?.OwnerId == VM.CurrentUserId)"
                               OnRemove="RemoveMember"
                               OnAdd="HandleAddMemberFromDrawer"
                               OnRename="HandleRenameFromDrawer"
                               OnToggleAdmin="HandleToggleAdmin"
                               OnTransferOwner="HandleTransferOwner"
                               OnDelete="HandleDeleteGroup"
                               OnLeave="HandleLeaveFromDrawer"
                               OnClose="CloseMembers" />
            }

            @if (VM.IsSelectionMode)
            {
                <div class="forward-action-bar">
                    <div class="selection-info">
                        <button class="icon-btn close-btn" @onclick="() => VM.IsSelectionMode = false">✕</button>
                        <span>@VM.SelectedMessageIds.Count Selected</span>
                    </div>
                    <button class="forward-submit-btn @(VM.SelectedMessageIds.Any() ? "active" : "")"
                            disabled="@(!VM.SelectedMessageIds.Any())" @onclick="() => VM.IsForwardModalOpen = true">
                        Forward ➔
                    </button>
                </div>
            }
        </div>
    }

    <PinDurationModal IsOpen="VM.IsPinModalOpen" OnCancel="() => VM.IsPinModalOpen = false" OnConfirm="VM.ConfirmPinAsync" />
    <ForwardModal IsOpen="VM.IsForwardModalOpen" OnClose="() => VM.IsForwardModalOpen = false" />
</div>

@code {
    [Parameter] public Guid RoomId { get; set; }

    private bool _membersOpen;
    private bool _attachmentsOpen;
    private bool _attachMenuOpen;
    private bool _renderQueued;
    private string currentMessage = string.Empty;
    private ElementReference inputRef;
    private string _toastMessage = string.Empty;
    private bool _showToast = false;
    private DotNetObjectReference<ChatPageInterop>? _objRef;
    private bool _escapeRegistered;
    private IJSObjectReference? _chatModule;
    private CancellationTokenSource? _readCts;
    private Guid _lastSentReadId = Guid.Empty;
    private MessageReactionsDetailsDto? _reactionDetails;
    private bool _reactionModalOpen;
    private Guid _reactionMessageId;
    private Guid? OpenReactionMessageId;
    private MessageModel? _editingMessage;
    private bool _isEnteringChat = false; // ✅ متغير جديد


    // ✅ متغيرات لتتبع التغييرات ومنع إعادة الرسم غير الضرورية
    private int _lastMessageCount = 0;
    private Guid _lastMessageId = Guid.Empty;

    protected override async Task OnInitializedAsync()
    {
        VM.IsPageActive = true;
        _isEnteringChat = true; // ✅ علامة إننا داخلين الشات

        var userId = await CurrentUser.GetUserIdAsync();
        NotificationManager.SetCurrentPage("chat", RoomId, userId);
        VM.Changed += OnVmChanged;
        VM.MessageReceived += OnMessageReceivedAsync;

        // ✅ إلغاء الاشتراك في أحداث UserOnline/Offline مؤقتاً
        Realtime.UserOnline -= OnUserOnline;
        Realtime.UserOffline -= OnUserOffline;

        Realtime.UserLastSeenUpdated += OnUserLastSeenUpdated;
        Realtime.GroupRenamed += HandleGroupRenamedRealtime;
        Realtime.UserBlockedByMeChanged += OnUserBlockedByMeChanged;
        Realtime.UserBlockedMeChanged += OnUserBlockedMeChanged;
        Realtime.RoomPresenceUpdated += OnRoomPresenceUpdated;
        Realtime.MessageReceiptStatsUpdated += OnMessageReceiptStatsUpdated;

        Realtime.MessageReceiptStatsUpdated += HandleGlobalStatsUpdate;
        Realtime.MemberAdded += (rid, uid, name) => InvokeAsync(async () =>
        {
            if (rid == RoomId)
            {
                await VM.RefreshRoomStateAsync(rid);
                StateHasChanged();
            }
        });
        Realtime.MemberRemoved += (rid, uid, name) => InvokeAsync(async () =>
        {
            if (rid == RoomId)
            {
                await VM.RefreshRoomStateAsync(rid);
                StateHasChanged();
            }
        });

        await VM.InitializeAsync(RoomId);
        _lastMessageCount = VM.Messages.Count;
        if (VM.Messages.Count > 0)
        {
            _lastMessageId = VM.Messages[^1].Id;
        }

        _isEnteringChat = false; // ✅ خلصنا
    }

    private void OnMessageReceiptStatsUpdated(Guid messageId, Guid roomId, int total, int delivered, int read)
    {
        if (roomId != RoomId) return;

        var msg = VM.Messages.FirstOrDefault(m => m.Id == messageId);
        if (msg == null) return;

        // حدّث العدادات
        msg.TotalRecipients = total;
        msg.DeliveredCount = delivered;
        msg.ReadCount = read;

        // في private: أول ما delivered >= 1 يبقى ✓✓
        // أول ما read >= 1 يبقى ✓✓ read
        msg.PersonalStatus =
            (read >= 1) ? EnterpriseChat.Client.Models.MessageStatus.Read :
            (delivered >= 1) ? EnterpriseChat.Client.Models.MessageStatus.Delivered :
            EnterpriseChat.Client.Models.MessageStatus.Sent;

        _ = InvokeAsync(StateHasChanged);
    }

// دالة مساعدة لاستقبال التحديث من SignalR مباشرة
private void HandleGlobalStatsUpdate(Guid mid, Guid rid, int t, int d, int r) => InvokeAsync(StateHasChanged);  


    private async void OnUserBlockedByMeChanged(Guid userId, bool blocked)
    {
        Console.WriteLine($"[Chat] OnUserBlockedByMeChanged: userId={userId}, blocked={blocked}, OtherUserId={VM.OtherUser?.Id}");

        if (VM.OtherUser?.Id == userId)
        {
            VM.IsBlockedByMe = blocked;

            if (blocked)
            {
                // ✅ بلوك جديد - خلاصة offline فوراً
                VM.OtherUser.IsOnline = false;
                VM.OtherUser.LastSeen = null;

                // ✅ إجبار الـ Realtime Client على تحديث حالته
                await Realtime.GetOnlineUsersAsync(); // ده هيطبق الفلترة تلقائياً
            }
            else
            {
                // ✅ فك البلوك - نشوف هو أونلاين ولا لأ
                var onlineUsers = await Realtime.GetOnlineUsersAsync();
                var isOnline = onlineUsers.Contains(userId);

                VM.OtherUser.IsOnline = isOnline;

                if (!isOnline)
                {
                    var status = await Realtime.GetUserOnlineStatus(userId);
                    var lastSeen = (DateTime?)status.GetType().GetProperty("LastSeen")?.GetValue(status);
                    VM.OtherUser.LastSeen = lastSeen;
                }
            }

            await InvokeAsync(StateHasChanged);
        }
    }
    private void OnUserBlockedMeChanged(Guid userId, bool blocked)
    {
        // لو الطرف الآخر هو اللي بلوكنا (مش محتاجين حاجة هنا حالياً)
        if (VM.OtherUser?.Id == userId)
        {
            // ممكن نحدث حالة معينة إذا احتجنا
            Console.WriteLine($"[Chat] User {userId} blocked me: {blocked}");
        }
    }
    private void OnUserOnline(Guid userId)
    {
        if (_isEnteringChat) return; // تجاهل أثناء الدخول
        if (VM.OtherUser?.Id == userId)
        {
            VM.OtherUser.IsOnline = true;
            VM.OtherUser.LastSeen = null;
            InvokeAsync(StateHasChanged);
        }
    }

    private void OnUserOffline(Guid userId)
    {
        if (_isEnteringChat) return; // تجاهل أثناء الدخول
        if (VM.OtherUser?.Id == userId)
        {
            VM.OtherUser.IsOnline = false;
            VM.OtherUser.LastSeen = DateTime.UtcNow;
            InvokeAsync(StateHasChanged);
        }
    }
     
    protected override async Task OnParametersSetAsync()
    {
        // ✅ كل ما يتغير الـ RoomId (بما في ذلك الريفرش)
        if (VM.OtherUser != null)
        {
            // جلب الحالة من السيرفر مباشرة
            var onlineUsers = await Realtime.GetOnlineUsersAsync();
            var isOnline = onlineUsers.Contains(VM.OtherUser.Id);

            // التحقق من البلوك محلياً
            var isBlocked = VM.IsBlockedByMe || VM.IsBlockedMe;

            if (isBlocked)
            {
                VM.OtherUser.IsOnline = false;
                VM.OtherUser.LastSeen = null;
            }
            else
            {
                VM.OtherUser.IsOnline = isOnline;
                if (!isOnline)
                {
                    // جلب آخر ظهور
                    var status = await Realtime.GetUserOnlineStatus(VM.OtherUser.Id);
                    var lastSeen = (DateTime?)status.GetType().GetProperty("LastSeen")?.GetValue(status);
                    VM.OtherUser.LastSeen = lastSeen;
                }
            }

            StateHasChanged();
        }
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && VM.OtherUser != null)
        {
            try
            {
                // ✅ التأكد من أن Realtime ليس null
                if (Realtime == null)
                {
                    Console.WriteLine("[Chat] Realtime is null");
                    return;
                }

                // ✅ التأكد من أن الاتصال موجود
                if (!Realtime.State.IsConnected)
                {
                    Console.WriteLine("[Chat] Realtime not connected, will retry later");
                    _ = Task.Run(async () =>
                    {
                        await Task.Delay(1000);
                        await InvokeAsync(StateHasChanged);
                    });
                    return;
                }

                var result = await Realtime.GetUserOnlineStatus(VM.OtherUser.Id);

                // ✅ التحقق من أن result ليس null
                if (result == null)
                {
                    Console.WriteLine("[Chat] GetUserOnlineStatus returned null");
                    return;
                }

                var isOnline = false;
                var lastSeen = (DateTime?)null;
                var isBlocked = false;

                try
                {
                    isOnline = (bool)result.GetType().GetProperty("IsOnline")?.GetValue(result, null)!;
                    lastSeen = (DateTime?)result.GetType().GetProperty("LastSeen")?.GetValue(result, null);
                    isBlocked = (bool)result.GetType().GetProperty("IsBlocked")?.GetValue(result, null)!;
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[Chat] Error extracting properties: {ex.Message}");
                }

                if (isBlocked || VM.IsBlockedByMe || VM.IsBlockedMe)
                {
                    VM.OtherUser.IsOnline = false;
                    VM.OtherUser.LastSeen = null;
                }
                else
                {
                    VM.OtherUser.IsOnline = isOnline;
                    if (!isOnline && lastSeen.HasValue)
                    {
                        VM.OtherUser.LastSeen = lastSeen.Value;
                    }
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[Chat] Error checking user status: {ex.Message}");
            }
        }
    }
    private async void HandleGroupRenamedRealtime(Guid rid, string name)
    {
        if (rid == RoomId)
        {
            await InvokeAsync(async () =>
            {
                await VM.RefreshRoomStateAsync(rid);
                await RoomsVM.RefreshRoomStatusesAsync();
                StateHasChanged();
            });
        }
    }


    private void OnUserLastSeenUpdated(Guid userId, DateTime lastSeen)
    {
        if (VM.OtherUser?.Id == userId)
        {
            VM.OtherUser.LastSeen = lastSeen;
            VM.OtherUser.IsOnline = false;
            InvokeAsync(StateHasChanged);
        }
    }
    #region Group Actions

    private async Task HandleRenameFromDrawer(string newName)
    {
        if (string.IsNullOrWhiteSpace(newName) || newName == VM.Room?.Name) return;
        try
        {
            _membersOpen = false;
            ShowToast("Updating...");
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10));
            await GroupsApi.UpdateGroupAsync(RoomId, newName, cts.Token);
            await Realtime.GroupRenamedAsync(RoomId, newName);
            ShowToast("Group renamed!");
        }
        catch (Exception ex) { ShowToast($"Error: {ex.Message}"); }
    }

    private async Task HandleAddMemberFromDrawer(Guid userId)
    {
        try
        {
            await GroupsApi.AddMemberAsync(RoomId, userId);
            ShowToast("Adding member...");
            _membersOpen = false;
            await VM.RefreshRoomStateAsync(RoomId);
        }
        catch (Exception ex) { ShowToast($"Error: {ex.Message}"); }
    }

    private async Task HandleToggleAdmin(Guid userId)
    {
        try
        {
            await GroupsApi.PromoteAdminAsync(RoomId, userId);
            ShowToast("Permissions updated!");
            await VM.RefreshRoomStateAsync(RoomId);
        }
        catch (Exception ex) { ShowToast(ex.Message); }
    }

    private async Task HandleTransferOwner(Guid userId)
    {
        try
        {
            await GroupsApi.TransferOwnerAsync(RoomId, userId);
            ShowToast("Ownership transferred!");
            _membersOpen = false;
            await VM.RefreshRoomStateAsync(RoomId);
        }
        catch (Exception ex) { ShowToast(ex.Message); }
    }

    private async Task HandleDeleteGroup()
    {
        try
        {
            await GroupsApi.DeleteGroupAsync(RoomId);
            Nav.NavigateTo("/rooms");
        }
        catch (Exception ex) { ShowToast(ex.Message); }
    }

    private async Task HandleLeaveFromDrawer()
    {
        try
        {
            await GroupsApi.LeaveGroupAsync(RoomId);
            Nav.NavigateTo("/rooms");
        }
        catch (Exception ex) { ShowToast(ex.Message); }
    }

    #endregion

    #region Helper Methods & Lifecycle

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(currentMessage)) return;

        // ✅ وقف الـ Typing فوراً قبل الإرسال
        try
        {
            if (Realtime.State.IsConnected)
                await Realtime.NotifyTypingAsync(RoomId);

            // ✅ Cancel الـ typing CTS عشان يبعت TypingStop فوراً
            await Task.Run(async () =>
            {
                if (Realtime is ChatRealtimeClient rc)
                {
                    await rc.StopTypingImmediatelyAsync(RoomId);
                }
            });
        }
        catch { }

        await HandleSendMessage(currentMessage.Trim());
        currentMessage = string.Empty;
        await ScrollToBottom();
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
            return;
        }
        await NotifyTyping();
    }

    private async Task HandleSendMessage(string text)
    {
        Guid? replyTo = ReplyCtx.MessageId != Guid.Empty ? ReplyCtx.MessageId : null;
        ReplyInfoModel? replySnapshot = null;

        if (replyTo.HasValue)
        {
            replySnapshot = new ReplyInfoModel
            {
                MessageId = ReplyCtx.MessageId,
                SenderName = ReplyCtx.SenderName,
                ContentPreview = ReplyCtx.ContentPreview,
                CreatedAt = ReplyCtx.CreatedAt,
                IsDeleted = false
            };

            var originalMessage = VM.Messages.FirstOrDefault(m => m.Id == ReplyCtx.MessageId);
            if (originalMessage != null) replySnapshot.SenderId = originalMessage.SenderId;
        }

        if (replyTo.HasValue)
            await VM.SendMessageWithReplyAsync(RoomId, text, replyTo, replySnapshot);
        else
            await VM.SendAsync(RoomId, text);

        await ScrollToBottom();
        ReplyCtx.Clear();
    }

    private async Task RetrySend(MessageModel msg) => await VM.SendAsync(RoomId, msg.Content);

    private Task NotifyTyping() => VM.NotifyTypingAsync(RoomId);

    private Task HandleReplyRequest(Guid messageId)
    {
        var message = VM.Messages.FirstOrDefault(m => m.Id == messageId);
        if (message == null) return Task.CompletedTask;

        ReplyCtx.MessageId = message.Id;
        ReplyCtx.SenderName = message.SenderId == VM.CurrentUserId ? "You" : VM.GetSenderName(message.SenderId);
        ReplyCtx.ContentPreview = message.Content.Length > 60 ? message.Content[..60] + "…" : message.Content;
        ReplyCtx.CreatedAt = message.CreatedAt;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private void StartEdit(MessageModel msg)
    {
        _editingMessage = msg;
        currentMessage = msg.Content;
        _ = JS.InvokeVoidAsync("eval", "document.querySelector('.composer-input').focus()");
    }

    private async Task HandleDeleteRequested(MessageModel msg)
    {
        if (msg.SenderId == VM.CurrentUserId)
        {
            if (await JS.InvokeAsync<bool>("confirm", "Delete for everyone?"))
                await VM.DeleteMessageAsync(msg.Id, true);
        }
        else
            await VM.DeleteMessageAsync(msg.Id, false);
    }

    private Task ToggleReaction(Guid messageId)
    {
        OpenReactionMessageId = OpenReactionMessageId == messageId ? null : messageId;
        return Task.CompletedTask;
    }

    private async Task OpenReactionDetails(Guid messageId)
    {
        _reactionMessageId = messageId;
        _reactionModalOpen = true;
        _reactionDetails = await VM.GetMessageReactionsDetailsAsync(messageId);
        StateHasChanged();
    }

    private async Task RemoveMyReaction(Guid userId)
    {
        if (_reactionMessageId == Guid.Empty) return;
        var message = VM.Messages.FirstOrDefault(m => m.Id == _reactionMessageId);
        if (message?.Reactions?.CurrentUserReactionType == null) return;
        await VM.AddReactionAsync(_reactionMessageId, message.Reactions.CurrentUserReactionType.Value);
        _reactionModalOpen = false;
    }

    private void CloseReactionDetails()
    {
        _reactionModalOpen = false;
        _reactionDetails = null;
        _reactionMessageId = Guid.Empty;
    }

    private async Task OnReaction(ReactionPayload payload) => await VM.AddReactionAsync(payload.MessageId, payload.Type);

    // ✅ الحل النهائي: تحديث الرسالة الموجودة بدل إضافة duplicate
    // في Chat.razor - داخل @code
    private async Task OnMessageReceivedAsync(MessageModel message)
    {
        if (VM.Room?.Type == "Private" && VM.OtherUser != null && message.SenderId == VM.CurrentUserId)
        {
            message.SenderId = VM.OtherUser.Id;
        }

        // ✅ لو الرسالة من الطرف الآخر في محادثة خاصة، خليها مقروءة فوراً
        if (VM.Room?.Type == "Private" && message.SenderId != VM.CurrentUserId)
        {
            message.PersonalStatus = ClientMessageStatus.Read;
            Console.WriteLine($"[Chat] 🟦 Forced Read for incoming private message {message.Id}");
        }
        // ✅ ابحث عن الرسالة لو موجودة
        var existingMessage = VM.Messages.FirstOrDefault(m => m.Id == message.Id);
        if (existingMessage != null)
        {
            // ✅ حدث الخصائص مباشرة في الـ ObservableCollection
            var needsUpdate = false;

            if (existingMessage.ReplyInfo?.ContentPreview != message.ReplyInfo?.ContentPreview)
            {
                existingMessage.ReplyInfo = message.ReplyInfo;
                needsUpdate = true;
            }

            if (existingMessage.Status != message.Status)
            {
                existingMessage.Status = message.Status;
                needsUpdate = true;
            }

            if (existingMessage.PersonalStatus != message.PersonalStatus)
            {
                existingMessage.PersonalStatus = message.PersonalStatus;
                needsUpdate = true;
            }

            if (existingMessage.DeliveredCount != message.DeliveredCount)
            {
                existingMessage.DeliveredCount = message.DeliveredCount;
                needsUpdate = true;
            }

            if (existingMessage.ReadCount != message.ReadCount)
            {
                existingMessage.ReadCount = message.ReadCount;
                needsUpdate = true;
            }

            if (existingMessage.TotalRecipients != message.TotalRecipients)
            {
                existingMessage.TotalRecipients = message.TotalRecipients;
                needsUpdate = true;
            }

            if (needsUpdate)
            {
                // ✅ ObservableCollection会自动 notify UI
                await InvokeAsync(StateHasChanged);
            }
            return;
        }

        // ✅ رسالة جديدة - أضفها للمجموعة
        VM.Messages.Add(message);

        // ✅ معالجة Reply Info
        if (message.ReplyToMessageId.HasValue && message.ReplyInfo == null)
        {
            var originalMessage = VM.Messages.FirstOrDefault(m => m.Id == message.ReplyToMessageId.Value);
            if (originalMessage != null)
            {
                message.ReplyInfo = new ReplyInfoModel
                {
                    MessageId = originalMessage.Id,
                    SenderId = originalMessage.SenderId,
                    SenderName = VM.GetSenderName(originalMessage.SenderId),
                    ContentPreview = originalMessage.Content.Length > 60
                        ? originalMessage.Content[..60] + "…"
                        : originalMessage.Content,
                    CreatedAt = originalMessage.CreatedAt,
                    IsDeleted = originalMessage.IsDeleted
                };
            }
        }

        // ✅ Mark as read فوراً لو مش منك
        if (message.SenderId != VM.CurrentUserId)
        {
            _ = VM.MarkRoomReadAsync(RoomId, message.Id);
        }

        await ScrollToBottom();
    }
    private Task HandleReachedBottom(Guid lastMessageId)
    {
        if (lastMessageId == Guid.Empty || lastMessageId == _lastSentReadId) return Task.CompletedTask;

        _readCts?.Cancel();
        _readCts?.Dispose();
        _readCts = new CancellationTokenSource();
        var ct = _readCts.Token;

        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(400, ct);
                if (ct.IsCancellationRequested) return;

                _lastSentReadId = lastMessageId;
                await VM.MarkRoomReadAsync(RoomId, lastMessageId);
                await InvokeAsync(() => RoomsVM.MarkRoomAsReadLocal(RoomId, lastMessageId));
            }
            catch { }
        }, ct);

        return Task.CompletedTask;
    }
    private void OnRoomPresenceUpdated(Guid roomId, int count)
    {
        // لو التحديث خاص بالغرفة الحالية
        if (roomId == RoomId)
        {
            Console.WriteLine($"[Chat] RoomPresenceUpdated for room {roomId}: {count} online");

            // تحديث العدد في الـ TopBar (اللي بيستقبل OnlineCount كـ Parameter)
            // محتاجين نحدث Parameter الـ OnlineCount في الـ TopBar

            _ = InvokeAsync(StateHasChanged);
        }
    }
    private async Task ScrollToMessage(Guid messageId)
    {
        var elementId = $"message-{messageId}";
        await JS.InvokeVoidAsync("scrollToMessage", elementId);
        await JS.InvokeVoidAsync("highlightMessage", elementId);
    }

    private async Task ScrollToBottom() => await JS.InvokeVoidAsync("scrollToBottomSmooth", "chat-messages");

    private Task RemoveMember(Guid userId) => VM.RemoveMemberAsync(RoomId, userId);

    private Task BlockOtherUser() => VM.OtherUser == null ? Task.CompletedTask : VM.BlockUserAsync(VM.OtherUser.Id);

    private Task ToggleMute() => VM.ToggleMuteAsync(RoomId);

    private void OpenMembers() { if (VM.Room?.Type == "Group") _membersOpen = true; }

    private void CloseMembers() => _membersOpen = false;

    private Task UnblockOtherUser() => VM.OtherUser == null ? Task.CompletedTask : VM.UnblockUserAsync(VM.OtherUser.Id);

    private void ShowToast(string message)
    {
        _toastMessage = message;
        _showToast = true;
        StateHasChanged();
        _ = Task.Delay(3000).ContinueWith(_ =>
        {
            _showToast = false;
            InvokeAsync(StateHasChanged);
        });
    }

    private async void OnVmChanged()
    {
        if (_renderQueued || VM.IsSearching) return;

        // ✅ منع إعادة الرسم إذا لم يتغير عدد الرسائل أو آخر رسالة
        var currentCount = VM.Messages.Count;
        var currentLastId = currentCount > 0 ? VM.Messages[^1].Id : Guid.Empty;

        if (currentCount == _lastMessageCount && currentLastId == _lastMessageId)
        {
            return;
        }

        _lastMessageCount = currentCount;
        _lastMessageId = currentLastId;

        _renderQueued = true;
        _ = InvokeAsync(async () =>
        {
            try
            {
                await Task.Delay(50);
                StateHasChanged();
                await JS.InvokeVoidAsync("scrollToBottomSmooth", "chat-messages");
            }
            finally
            {
                _renderQueued = false;
            }
        });
    }

    public void Dispose()
    {
        VM.DeactivateChat();
        VM.IsPageActive = false;
        VM.Changed -= OnVmChanged;
        VM.MessageReceived -= OnMessageReceivedAsync;
        Realtime.GroupRenamed -= HandleGroupRenamedRealtime;
        Realtime.UserLastSeenUpdated -= OnUserLastSeenUpdated;
        Realtime.UserBlockedByMeChanged -= OnUserBlockedByMeChanged;
        Realtime.UserBlockedMeChanged -= OnUserBlockedMeChanged;
        Realtime.RoomPresenceUpdated -= OnRoomPresenceUpdated;
        Realtime.MessageReceiptStatsUpdated -= OnMessageReceiptStatsUpdated;

        NotificationManager.SetCurrentPage("unknown", null, Guid.Empty);

        _readCts?.Cancel();
        _readCts?.Dispose();

        // ✅ تحديث جميع الرسائل كمقروءة عند الخروج
        _ = Task.Run(async () =>
        {
            try
            {
                if (VM.Room?.Type == "Private" && VM.Messages.Any())
                {
                    // نجيب آخر رسالة من الطرف الآخر
                    var lastMessageFromOther = VM.Messages
                        .Where(m => m.SenderId != VM.CurrentUserId)
                        .OrderByDescending(m => m.CreatedAt)
                        .FirstOrDefault();

                    if (lastMessageFromOther != null)
                    {
                        Console.WriteLine($"[Chat] Marking ALL messages as read on exit up to {lastMessageFromOther.Id}");

                        // 1. تحديث جميع الرسائل محلياً
                        foreach (var msg in VM.Messages.Where(m => m.SenderId != VM.CurrentUserId))
                        {
                            if (msg.PersonalStatus < ClientMessageStatus.Read)
                            {
                                msg.PersonalStatus = ClientMessageStatus.Read;
                            }
                        }

                        // 2. تحديث السيرفر بآخر رسالة
                        await VM.MarkRoomReadAsync(RoomId, lastMessageFromOther.Id);

                        // 3. تحديث الـ Sidebar
                        if (RoomsVM != null)
                        {
                            RoomsVM.UpdateLastMessageStatus(RoomId, lastMessageFromOther.Id, ClientMessageStatus.Read);
                            RoomsVM.MarkRoomAsReadLocal(RoomId, lastMessageFromOther.Id);
                        }

                        Console.WriteLine($"[Chat] ✅ Updated all messages as read on exit");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[Chat] Error marking messages as read on exit: {ex.Message}");
            }
        });

        // ✅ فقط اترك الغرفة ولا تقطع الاتصال
        _ = Task.Run(async () =>
        {
            try
            {
                if (Realtime.State.IsConnected)
                {
                    await Realtime.LeaveRoomAsync(RoomId);
                    Console.WriteLine($"[Chat] Left room {RoomId}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[Chat] Error leaving room: {ex.Message}");
            }
        });

        _ = Task.Run(async () =>
        {
            try
            {
                if (_chatModule != null)
                {
                    await _chatModule.InvokeVoidAsync("unregisterEscape");
                    await _chatModule.DisposeAsync();
                }
            }
            catch { }
        });

        _objRef?.Dispose();
    }
private void OpenAttachmentsDrawer() { _attachMenuOpen = false; _attachmentsOpen = true; }

    private void CloseAttachments() => _attachmentsOpen = false;

    private void ToggleAttachMenu() => _attachMenuOpen = !_attachMenuOpen;

    private void CloseAttachMenuIfOpen()
    {
        if (_attachMenuOpen)
        {
            _attachMenuOpen = false;
            StateHasChanged();
        }
    }

    private void TriggerFileUpload()
    {
        _attachMenuOpen = false;
        _ = JS.InvokeVoidAsync("eval", "document.getElementById('attach-file-input').click()");
    }

    private async Task OnFileSelected(InputFileChangeEventArgs e)
    {
        if (RoomId == Guid.Empty) return;
        bool uploaded = false;

        foreach (var file in e.GetMultipleFiles())
        {
            const long maxBytes = 25 * 1024 * 1024;
            await using var stream = file.OpenReadStream(maxAllowedSize: maxBytes);
            await AttachmentsApi.UploadAsync(RoomId, stream, file.Name, file.ContentType);
            uploaded = true;
        }

        if (uploaded) ShowToast("File uploaded successfully!");
        StateHasChanged();
    }
    

 
    private sealed class ChatPageInterop
    {
        private readonly Chat _page;
        public ChatPageInterop(Chat page) => _page = page;

        [JSInvokable]
        public Task OnGlobalEscape()
        {
            var changed = false;
            if (_page._attachmentsOpen) { _page.CloseAttachments(); changed = true; }
            if (_page._membersOpen) { _page.CloseMembers(); changed = true; }
            if (_page._attachMenuOpen) { _page._attachMenuOpen = false; changed = true; }
            return changed ? _page.InvokeAsync(_page.StateHasChanged) : Task.CompletedTask;
        }
    }
    #endregion
}