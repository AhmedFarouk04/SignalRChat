@using EnterpriseChat.Client.Models
@using EnterpriseChat.Domain.Enums
@using EnterpriseChat.Client.Services.JsInterop
@inject IScrollService Scroll

<div class="message-list-wrap">
    <div class="message-list" @ref="listRef" @onscroll="OnScroll">

        @if (showNewDivider)
        {
            <div class="unread-divider">New messages</div>
        }

        @{
            var originalMessages = Messages
            .Where(m => !m.ReplyToMessageId.HasValue)
            .DistinctBy(m => m.Id)
            .OrderBy(m => m.CreatedAt)
            .ToList();
        }

        @for (int i = 0; i < originalMessages.Count; i++)
        {
            var msg = originalMessages[i];
            var prev = i > 0 ? originalMessages[i - 1] : null;
            var next = i < originalMessages.Count - 1 ? originalMessages[i + 1] : null;

            var currDate = msg.CreatedAt.ToLocalTime().Date;
            var prevDate = prev?.CreatedAt.ToLocalTime().Date;

            if (prev is null || prevDate != currDate)
            {
                <div class="date-sep" @key="@($"date-{currDate:yyyyMMdd}")">@FormatDateLabel(currDate)</div>
            }

            @if (IsSystemMessage(msg))
            {
                <div class="system-message-container" @key="@($"sys-{msg.Id}")">
                    <div class="system-content">
                        <span class="system-text">@FormatSystemMessage(msg.Content)</span>
                    </div>
                </div>
            }
            else
            {
                var samePrev = IsSameGroup(prev, msg);
                var sameNext = IsSameGroup(msg, next);
                var pos = (!samePrev && !sameNext) ? "single" :
                (!samePrev && sameNext) ? "start" :
                (samePrev && sameNext) ? "mid" : "end";

                @* ✅ استخدام Fixed @key عشان منع إعادة الإنشاء *@
                <MessageBubble @key="@msg.Id"
                               Message="@msg"
                               CurrentUserId="@CurrentUserId"
                               GroupMembers="@GroupMembers"
                               GroupPosition="@pos"
                               IsNew="@(newIds.Contains(msg.Id) && !_processedNewMessages.Contains(msg.Id))"
                               ShowMeta="true"
                               OnRetry="@OnRetry"
                               OnReaction="@OnReaction"
                               OnReplyRequested="@OnReplyRequested"
                               OnScrollToMessage="@OnScrollToMessage"
                               OnOpenReactionDetails="@OnOpenReactionDetails"
                               OpenReactionMessageId="@OpenReactionMessageId"
                               OnEditRequested="OnEditRequested"
                               OnDeleteRequested="OnDeleteRequested"
                               OnToggleReaction="@OnToggleReaction" />

                @foreach (var reply in GetRepliesForMessage(msg.Id))
                {
                    @* ✅ نفس الشي للردود *@
                    <div class="reply-container" @key="@($"reply-{reply.Id}")" data-parent="@msg.Id">
                        <MessageBubble @key="@reply.Id"
                                       Message="@reply"
                                       CurrentUserId="@CurrentUserId"
                                       GroupMembers="@GroupMembers"
                                       GroupPosition="single"
                                       IsNew="@(newIds.Contains(reply.Id) && !_processedNewMessages.Contains(reply.Id))"
                                       ShowMeta="true"
                                       OnRetry="@OnRetry"
                                       OnReaction="@OnReaction"
                                       OnReplyRequested="@OnReplyRequested"
                                       OnScrollToMessage="@OnScrollToMessage"
                                       OnOpenReactionDetails="@OnOpenReactionDetails"
                                       OpenReactionMessageId="@OpenReactionMessageId"
                                       OnToggleReaction="@OnToggleReaction"
                                       OnEditRequested="OnEditRequested"
                                       OnDeleteRequested="OnDeleteRequested" />
                    </div>
                }
            }
        }
    </div>

    @if (!isAtBottom)
    {
        <button class="scroll-bottom" @onclick="ScrollDown">↓ New</button>
    }
</div>

@code {
    [Parameter] public IReadOnlyList<MessageModel> Messages { get; set; } = [];
    [Parameter] public Guid CurrentUserId { get; set; }
    [Parameter] public RoomModel? Room { get; set; } = null;
    [Parameter] public List<UserModel> GroupMembers { get; set; } = new();
    [Parameter] public EventCallback<MessageModel> OnRetry { get; set; }
    [Parameter] public EventCallback<Guid> OnReachedBottom { get; set; }
    [Parameter] public bool AutoScroll { get; set; } = true;
    [Parameter] public EventCallback<Guid> OnOpenReactionDetails { get; set; }
    [Parameter] public EventCallback<MessageModel> OnEditRequested { get; set; }
    [Parameter] public EventCallback<MessageModel> OnDeleteRequested { get; set; }
    [Parameter] public Guid? OpenReactionMessageId { get; set; }
    [Parameter] public EventCallback<Guid> OnToggleReaction { get; set; }
    [Parameter] public EventCallback<ReactionPayload> OnReaction { get; set; }
    [Parameter] public EventCallback<Guid> OnReplyRequested { get; set; }
    [Parameter] public EventCallback<Guid> OnScrollToMessage { get; set; }

    private ElementReference listRef;
    private int lastMessageCount;
    private bool isAtBottom = true;
    private bool showNewDivider;
    private readonly HashSet<Guid> newIds = new();
    private readonly HashSet<Guid> _processedNewMessages = new(); // ✅ متتبع الرسائل الجديدة المعالجة
    private string _lastMessagesHash = string.Empty;
    private bool _isCheckingBottom = false;

    private bool IsSystemMessage(MessageModel msg)
    {
        if (msg == null) return false;
        if (msg.IsSystem || msg.Type == "System") return true;
        if (string.IsNullOrEmpty(msg.Content)) return false;

        var lower = msg.Content.ToLower();
        return lower.Contains("created the group") ||
               lower.Contains("was added by") ||
               lower.Contains("was removed by") ||
               lower.Contains("left") ||
               lower.Contains("pinned a message");
    }

    private List<MessageModel> GetRepliesForMessage(Guid messageId)
    {
        return Messages.Where(m => m.ReplyToMessageId == messageId)
                       .OrderBy(m => m.CreatedAt)
                       .ToList();
    }

    private string FormatSystemMessage(string content)
        => content.Replace("created the group", "created group")
                  .Replace("was added by", "added by")
                  .Replace("was removed by", "removed by");

    private static bool IsSameGroup(MessageModel? a, MessageModel? b)
    {
        if (a is null || b is null) return false;
        if (a.SenderId != b.SenderId) return false;
        var dt = (b.CreatedAt - a.CreatedAt).Duration();
        return dt <= TimeSpan.FromMinutes(2);
    }

    private static string FormatDateLabel(DateTime date)
    {
        var today = DateTime.Now.Date;
        if (date == today) return "TODAY";
        if (date == today.AddDays(-1)) return "YESTERDAY";
        if (date > today.AddDays(-7)) return date.ToString("dddd").ToUpper();
        return date.ToString("MMM dd, yyyy").ToUpper();
    }

    // ✅ تحسين: منع إعادة الرسم غير الضرورية (بدون async)
    protected override bool ShouldRender()
    {
        // حساب Hash للرسائل الحالية
        var currentHash = string.Join("|", Messages.Select(m => $"{m.Id}:{m.Content?.Length}:{m.PersonalStatus}:{m.ReadCount}:{m.DeliveredCount}"));

        if (_lastMessagesHash == currentHash)
        {
            return false;
        }

        _lastMessagesHash = currentHash;
        return true;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (Messages.Count == 0)
        {
            lastMessageCount = 0;
            return;
        }

        // ✅ منع إعادة المعالجة إذا كان العدد نفسه
        if (Messages.Count <= lastMessageCount)
        {
            return;
        }

        // ✅ التحقق من isAtBottom بشكل غير متزامن
        var atBottom = await CheckIfAtBottom();

        if (AutoScroll && atBottom)
        {
            try
            {
                await Scroll.ScrollToBottomAsync(listRef);

                // تنظيف الـ new messages
                showNewDivider = false;
                newIds.Clear();
                _processedNewMessages.Clear();

                if (Messages.Count > 0)
                {
                    await OnReachedBottom.InvokeAsync(Messages[^1].Id);
                }
            }
            catch { }
        }
        else
        {
            // إضافة الرسائل الجديدة فقط
            for (int i = lastMessageCount; i < Messages.Count; i++)
            {
                var newMsg = Messages[i];
                newIds.Add(newMsg.Id);

                // ✅ لو الرسالة مش جديدة (قدام), نضيفها للمعالجة عشان متظهرش كـ New
                if (newMsg.CreatedAt < DateTime.UtcNow.AddSeconds(-30))
                {
                    _processedNewMessages.Add(newMsg.Id);
                }
            }
            showNewDivider = newIds.Count > 0;
        }

        lastMessageCount = Messages.Count;
    }

    private async Task<bool> CheckIfAtBottom()
    {
        if (_isCheckingBottom) return isAtBottom;

        try
        {
            _isCheckingBottom = true;
            return await Scroll.IsAtBottomAsync(listRef);
        }
        catch
        {
            return true;
        }
        finally
        {
            _isCheckingBottom = false;
        }
    }

    private CancellationTokenSource? _scrollCts;
    private Guid _lastBottomReportedMessageId = Guid.Empty;

    private async Task OnScroll()
    {
        _scrollCts?.Cancel();
        _scrollCts = new CancellationTokenSource();
        try { await Task.Delay(80, _scrollCts.Token); } catch { return; }

        var atBottom = await Scroll.IsAtBottomAsync(listRef);
        var wasBottom = isAtBottom;
        isAtBottom = atBottom;

        if (!isAtBottom) return;

        // ✅ تنظيف الـ new messages عند الوصول للأسفل
        if (showNewDivider || newIds.Count > 0)
        {
            showNewDivider = false;
            newIds.Clear();
            _processedNewMessages.Clear();
            await InvokeAsync(StateHasChanged);
        }

        if (Messages.Count == 0) return;

        var lastId = Messages[^1].Id;
        if (lastId == _lastBottomReportedMessageId && wasBottom) return;

        _lastBottomReportedMessageId = lastId;
        await OnReachedBottom.InvokeAsync(lastId);
    }

    private async Task ScrollDown()
    {
        await Scroll.ScrollToBottomSmoothAsync(listRef);
        isAtBottom = true;

        // ✅ تنظيف الـ new messages
        showNewDivider = false;
        newIds.Clear();
        _processedNewMessages.Clear();

        if (Messages.Count > 0)
        {
            await OnReachedBottom.InvokeAsync(Messages[^1].Id);
        }
    }

    public async Task ForceRefreshAsync()
    {
        await InvokeAsync(StateHasChanged);
    }
}