@using EnterpriseChat.Client.Models
@using EnterpriseChat.Client.Services.JsInterop
@inject IScrollService Scroll

<div class="message-list-wrap">
    <div class="message-list" @ref="listRef" @onscroll="OnScroll">

        @if (showNewDivider)
        {
            <div class="unread-divider">New messages</div>
        }

        @for (int i = 0; i < Messages.Count; i++)
        {
            var msg = Messages[i];
            var prev = i > 0 ? Messages[i - 1] : null;
            var next = i < Messages.Count - 1 ? Messages[i + 1] : null;

            // Date separator
            var currDate = msg.CreatedAt.ToLocalTime().Date;
            var prevDate = prev?.CreatedAt.ToLocalTime().Date;
            if (prev is null || prevDate != currDate)
            {
                <div class="date-sep">@FormatDateLabel(currDate)</div>
            }

            var samePrev = IsSameGroup(prev, msg);
            var sameNext = IsSameGroup(msg, next);

            var pos =
            (!samePrev && !sameNext) ? "single" :
            (!samePrev && sameNext) ? "start" :
            (samePrev && sameNext) ? "mid" :
            "end";

            var showMeta = !sameNext;

            <MessageBubble Message="msg"
                           CurrentUserId="CurrentUserId"
                           OnRetry="OnRetry"
                           GroupPosition="@pos"
                           ShowMeta="@showMeta"
                           IsNew="@newIds.Contains(msg.Id)" />
        }
    </div>

    @if (!isAtBottom)
    {
        <button class="scroll-bottom" @onclick="ScrollDown">
            ↓ New
        </button>
    }
</div>

@code {
    [Parameter] public IReadOnlyList<MessageModel> Messages { get; set; } = [];
    [Parameter] public Guid CurrentUserId { get; set; }
    [Parameter] public EventCallback<MessageModel> OnRetry { get; set; }
    [Parameter] public EventCallback<Guid> OnReachedBottom { get; set; }
    [Parameter] public bool AutoScroll { get; set; } = true;

    private ElementReference listRef;

    private int lastMessageCount;
    private bool isAtBottom = true;
    private bool showNewDivider;

    private readonly HashSet<Guid> newIds = new();

    private static bool IsSameGroup(MessageModel? a, MessageModel? b)
    {
        if (a is null || b is null) return false;
        if (a.SenderId != b.SenderId) return false;

        var dt = (b.CreatedAt - a.CreatedAt).Duration();
        return dt <= TimeSpan.FromMinutes(2);
    }

    private static string FormatDateLabel(DateTime date)
    {
        var today = DateTime.Now.Date;
        if (date == today) return "Today";
        if (date == today.AddDays(-1)) return "Yesterday";
        return date.ToString("ddd, dd MMM");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (listRef.Context is null) return;

        if (firstRender)
        {
            if (AutoScroll) await Scroll.ScrollToBottomAsync(listRef);
            lastMessageCount = Messages.Count;
            return;
        }

        if (Messages.Count == lastMessageCount) return;

        // messages added
        if (Messages.Count > lastMessageCount)
        {
            isAtBottom = await Scroll.IsAtBottomAsync(listRef);

            if (AutoScroll && isAtBottom)
            {
                await Scroll.ScrollToBottomAsync(listRef);
                showNewDivider = false;
                newIds.Clear();

                if (Messages.Count > 0)
                    await OnReachedBottom.InvokeAsync(Messages[^1].Id);
            }
            else
            {
                // mark newly arrived messages as "new"
                for (int i = lastMessageCount; i < Messages.Count; i++)
                    newIds.Add(Messages[i].Id);

                showNewDivider = true;
            }
        }

        lastMessageCount = Messages.Count;
    }

    private async Task OnScroll()
    {
        if (listRef.Context is null) return;

        isAtBottom = await Scroll.IsAtBottomAsync(listRef);

        if (isAtBottom)
        {
            showNewDivider = false;
            newIds.Clear();

            if (Messages.Count > 0)
                await OnReachedBottom.InvokeAsync(Messages[^1].Id);
        }
    }

    private async Task ScrollDown()
    {
        if (listRef.Context is null) return;

        await Scroll.ScrollToBottomSmoothAsync(listRef);
        isAtBottom = true;
        showNewDivider = false;
        newIds.Clear();

        if (Messages.Count > 0)
            await OnReachedBottom.InvokeAsync(Messages[^1].Id);
    }
}
