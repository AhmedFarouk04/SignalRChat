@using EnterpriseChat.Client.Models
@using EnterpriseChat.Client.Services.JsInterop
@inject IScrollService Scroll

<div class="message-list-wrap">
    <div class="message-list" @ref="listRef" @onscroll="OnScroll">

        @if (showNewDivider)
        {
            <div class="unread-divider">New messages</div>
        }

        @for (int i = 0; i < Messages.Count; i++)
        {
            var msg = Messages[i];
            var prev = i > 0 ? Messages[i - 1] : null;
            var next = i < Messages.Count - 1 ? Messages[i + 1] : null;

            var currDate = msg.CreatedAt.ToLocalTime().Date;
            var prevDate = prev?.CreatedAt.ToLocalTime().Date;
            if (prev is null || prevDate != currDate)
            {
                <div class="date-sep">@FormatDateLabel(currDate)</div>
            }

            var samePrev = IsSameGroup(prev, msg);
            var sameNext = IsSameGroup(msg, next);

            var pos =
            (!samePrev && !sameNext) ? "single" :
            (!samePrev && sameNext) ? "start" :
            (samePrev && sameNext) ? "mid" :
            "end";

            var showMeta = !sameNext;

            <MessageBubble Message="msg"
                           CurrentUserId="CurrentUserId"
                           OnRetry="OnRetry"
                           GroupPosition="@pos"
                           ShowMeta="@showMeta"
                           IsNew="@newIds.Contains(msg.Id)" />
        }
    </div>

    @if (!isAtBottom)
    {
        <button class="scroll-bottom" @onclick="ScrollDown">
            ↓ New
        </button>
    }
</div>

@code {
    [Parameter] public IReadOnlyList<MessageModel> Messages { get; set; } = [];
    [Parameter] public Guid CurrentUserId { get; set; }
    [Parameter] public EventCallback<MessageModel> OnRetry { get; set; }
    [Parameter] public EventCallback<Guid> OnReachedBottom { get; set; }
    [Parameter] public bool AutoScroll { get; set; } = true;

    private ElementReference listRef;

    private int lastMessageCount;
    private bool isAtBottom = true;
    private bool _wasAtBottom = true; // ✅ حالة القاع قبل التغيير
    private bool showNewDivider;

    private readonly HashSet<Guid> newIds = new();

    private static bool IsSameGroup(MessageModel? a, MessageModel? b)
    {
        if (a is null || b is null) return false;
        if (a.SenderId != b.SenderId) return false;

        var dt = (b.CreatedAt - a.CreatedAt).Duration();
        return dt <= TimeSpan.FromMinutes(2);
    }

    private static string FormatDateLabel(DateTime date)
    {
        var today = DateTime.Now.Date;
        if (date == today) return "Today";
        if (date == today.AddDays(-1)) return "Yesterday";
        return date.ToString("ddd, dd MMM");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (listRef.Context is null) return;

        if (firstRender)
        {
            if (AutoScroll)
            {
                await Scroll.ScrollToBottomAsync(listRef);
                isAtBottom = true;
                _wasAtBottom = true;
            }

            lastMessageCount = Messages.Count;
            return;
        }

        if (Messages.Count == lastMessageCount) return;

        // messages added
        if (Messages.Count > lastMessageCount)
        {
            var wasAtBottom = isAtBottom; // ✅ قبل الزيادة

            if (AutoScroll && wasAtBottom)
            {
                await Scroll.ScrollToBottomAsync(listRef);
                showNewDivider = false;
                newIds.Clear();

                if (Messages.Count > 0)
                    await OnReachedBottom.InvokeAsync(Messages[^1].Id);
            }
            else
            {
                for (int i = lastMessageCount; i < Messages.Count; i++)
                    newIds.Add(Messages[i].Id);

                showNewDivider = true;
            }
        }


        lastMessageCount = Messages.Count;
    }

    private CancellationTokenSource? _scrollCts;
    private Guid _lastBottomReportedMessageId = Guid.Empty;

    private async Task OnScroll()
    {
        if (listRef.Context is null) return;

        // Debounce للـ scroll (علشان event بيضرب كتير)
        _scrollCts?.Cancel();
        _scrollCts = new CancellationTokenSource();
        var token = _scrollCts.Token;

        try
        {
            await Task.Delay(80, token); // 60-120ms مناسب
        }
        catch (TaskCanceledException)
        {
            return;
        }

        // احسب هل أنت عند القاع فعلاً
        var atBottom = await Scroll.IsAtBottomAsync(listRef);
        var wasBottom = isAtBottom;
        isAtBottom = atBottom;

        if (!isAtBottom) return;

        // وصلت للقاع الآن (أو رجعت للقاع): امسح new divider
        showNewDivider = false;
        newIds.Clear();

        if (Messages.Count == 0) return;

        // امنع تكرار نفس النداء لو نفس آخر رسالة
        var lastId = Messages[^1].Id;
        if (lastId == _lastBottomReportedMessageId && wasBottom) return;

        _lastBottomReportedMessageId = lastId;
        await OnReachedBottom.InvokeAsync(lastId);
    }


    private async Task ScrollDown()
    {
        if (listRef.Context is null) return;

        await Scroll.ScrollToBottomSmoothAsync(listRef);
        isAtBottom = true;
        _wasAtBottom = true;

        showNewDivider = false;
        newIds.Clear();

        if (Messages.Count > 0)
            await OnReachedBottom.InvokeAsync(Messages[^1].Id);
    }
}
