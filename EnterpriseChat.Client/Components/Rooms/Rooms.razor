@page "/rooms"
@attribute [Microsoft.AspNetCore.Authorization.Authorize]
@using EnterpriseChat.Client.Services.Ui
@using EnterpriseChat.Client.ViewModels
@using EnterpriseChat.Client.Services.Realtime
@inject RoomsViewModel VM
@inject IChatRealtimeClient Realtime
@inject NavigationManager Nav
@implements IAsyncDisposable
@inject RoomFlagsStore Flags



@implements IDisposable

<div class="rooms-page">
    <div class="rooms-header">
        <h2 class="rooms-title">Chats</h2>
    </div>

    <div class="rooms-toolbar">
        <input class="rooms-search"
               id="roomsSearch"
               aria-label="Search chats"
               placeholder="Search chats…"
               value="@VM.SearchQuery"
               @oninput="OnSearch"
               autofocus />

        <div class="rooms-tabs">
            <button class="tab @(VM.ActiveFilter == RoomsFilter.All ? "active" : "")"
                    @onclick="() => VM.SetFilter(RoomsFilter.All)">
                All
            </button>

            <button class="tab @(VM.ActiveFilter == RoomsFilter.Unread ? "active" : "")"
                    @onclick="() => VM.SetFilter(RoomsFilter.Unread)">
                Unread
            </button>

            <button class="tab @(VM.ActiveFilter == RoomsFilter.Muted ? "active" : "")"
                    @onclick="() => VM.SetFilter(RoomsFilter.Muted)">
                Muted
            </button>

            <button class="tab @(VM.ActiveFilter == RoomsFilter.Groups ? "active" : "")"
                    @onclick="() => VM.SetFilter(RoomsFilter.Groups)">
                Groups
            </button>

            <button class="tab @(VM.ActiveFilter == RoomsFilter.Private ? "active" : "")"
                    @onclick="() => VM.SetFilter(RoomsFilter.Private)">
                Private
            </button>
        </div>
    </div>

    @if (VM.IsLoading)
    {
        <ul class="rooms-list">
            @for (int i = 0; i < 8; i++)
            {
                <li class="room-skeleton">
                    <div class="sk-avatar"></div>
                    <div class="sk-lines">
                        <div class="sk-line w-60"></div>
                        <div class="sk-line w-90"></div>
                    </div>
                </li>
            }
        </ul>
    }
    else if (VM.IsEmpty)
    {
        <div class="rooms-empty">
            <div class="rooms-empty-title">No conversations yet</div>
            <div class="rooms-empty-sub">Start a new chat from Users — or wait for messages.</div>
        </div>
    }
    else
    {
        <ul class="rooms-list">
            @foreach (var room in VM.VisibleRooms)
            {
                <RoomListItem @key="room.Id"
                              Room="room"
                              IsOnline="@(IsBlockedPrivate(room) ? (bool?)null :
                                                       (room.Type == "Private" && room.OtherUserId != null
                                                           && _onlineMap.TryGetValue(room.OtherUserId.Value, out var on)
                                                               ? on
                                                               : (bool?)null))"
                      LastSeenText="@(IsBlockedPrivate(room) ? null : GetLastSeenText(room))"
                      IsTyping="@(IsBlockedPrivate(room) ? false :
                                               (room.Type == "Private" && room.OtherUserId != null
                                                   && _typingMap.Contains(room.OtherUserId.Value)))" />

                }
        </ul>
    }
</div>

@code {
    private CancellationTokenSource? _searchCts;

    // presence state
    private readonly Dictionary<Guid, bool> _onlineMap = new();
    private readonly Dictionary<Guid, DateTime> _lastSeenMap = new();

    // typing in rooms list:
    // NOTE: Rooms page مش بتنضم لكل الرومات، فغالبًا مش هيوصل typing events.
    // هنسيبها جاهزة، ولما تعمل JoinRoomsList() في السيرفر هتشتغل تلقائيًا.
    private readonly HashSet<Guid> _typingMap = new();

    private bool _realtimeSubscribed;

    protected override async Task OnInitializedAsync()
    {
        VM.Changed += OnVmChanged;
        SubscribeRealtime();

        // 1️⃣ ابدأ الاتصال وتحميل البيانات بالتوازي
        var connectTask = Realtime.ConnectAsync();
        var loadTask = VM.LoadAsync();

        await Task.WhenAll(connectTask, loadTask);
        Console.WriteLine("[RoomsPage] Core data loaded ✅");

        // 2️⃣ ✅ الحل الذكي: بدلاً من الانضمام لكل الرومات هنا وإحداث فوضى
        // نكتفي بحدث RefreshRoomStatusesAsync الذي يجلب الحالة النهائية
        await VM.RefreshRoomStatusesAsync();

        // 3️⃣ الانضمام للرومات في الخلفية بدون انتظار (Fire and Forget)
        // وبدون إجبار الواجهة على إعادة الترتيب العنيف
        _ = Task.Run(async () =>
        {
            foreach (var room in VM.Rooms)
            {
                try
                {
                    await Realtime.JoinRoomAsync(room.Id);
                    await Task.Delay(20); // Delay صغير جداً لتخفيف الحمل
                }
                catch { }
            }
        });

        ApplyOnlineSnapshot();
        await InvokeAsync(StateHasChanged);
    }
    private void SubscribeRealtime()
    {
        if (_realtimeSubscribed) return;
        _realtimeSubscribed = true;

        Realtime.UserOnline += OnUserOnline;
        Realtime.UserOffline += OnUserOffline;

        // typing (غالبًا مش هيوصل لحد ما تعمل JoinRoomsList)
        Realtime.TypingStarted += OnTypingStarted;
        Realtime.TypingStopped += OnTypingStopped;
        Realtime.RoomUpdated += OnRoomUpdatedDirect;

        // لو حصل reconnect نعيد snapshot
        Realtime.Reconnected += OnRealtimeReconnected;
    }

    private void UnsubscribeRealtime()
    {
        if (!_realtimeSubscribed) return;
        _realtimeSubscribed = false;

        Realtime.UserOnline -= OnUserOnline;
        Realtime.UserOffline -= OnUserOffline;

        Realtime.TypingStarted -= OnTypingStarted;
        Realtime.TypingStopped -= OnTypingStopped;

        Realtime.Reconnected -= OnRealtimeReconnected;
    }

    private void OnRealtimeReconnected()
    {
        ApplyOnlineSnapshot();
        _ = InvokeAsync(StateHasChanged);
    }

    private void ApplyOnlineSnapshot()
    {
        // snapshot من السيرفر: GetOnlineUsers جوا ConnectAsync
        var set = Realtime.State.OnlineUsers?.ToHashSet() ?? new HashSet<Guid>();

        // هنحدّث بس الـ users اللي ظاهرين في rooms
        foreach (var r in VM.Rooms.Where(x => x.Type == "Private" && x.OtherUserId != null))
        {
            var uid = r.OtherUserId!.Value;
            var isOnline = set.Contains(uid);

            _onlineMap[uid] = isOnline;
            if (isOnline)
                _lastSeenMap.Remove(uid);
        }
    }

    private void OnUserOnline(Guid userId)
    {
        _onlineMap[userId] = true;
        _lastSeenMap.Remove(userId);

        _ = InvokeAsync(StateHasChanged);
    }

    private void OnUserOffline(Guid userId)
    {
        _onlineMap[userId] = false;
        _lastSeenMap[userId] = DateTime.Now;

        // لو كان typing شغال نخليه يقف
        _typingMap.Remove(userId);

        _ = InvokeAsync(StateHasChanged);
    }

    private void OnTypingStarted(Guid roomId, Guid userId)
    {
        // rooms list: typing يظهر فقط للـ private users
        _typingMap.Add(userId);
        _ = InvokeAsync(StateHasChanged);
    }

    private void OnTypingStopped(Guid roomId, Guid userId)
    {
        _typingMap.Remove(userId);
        _ = InvokeAsync(StateHasChanged);
    }
    private bool IsBlockedPrivate(RoomListItemModel room)
    {
        if (room.Type != "Private" || room.OtherUserId == null) return false;
        return Flags.GetBlocked(room.OtherUserId.Value);
    }

    private string? GetLastSeenText(RoomListItemModel room)
    {
        if (room.Type != "Private" || room.OtherUserId == null) return null;

        if (Flags.GetBlocked(room.OtherUserId.Value))
            return null; // ✅ اخفاء بالكامل

        var id = room.OtherUserId.Value;

        if (_onlineMap.TryGetValue(id, out var on) && on)
            return null;

        if (_lastSeenMap.TryGetValue(id, out var dt))
            return $"Last seen {dt:HH:mm}";

        return "Offline";
    }


    private void OnSearch(ChangeEventArgs e)
    {
        var q = e.Value?.ToString() ?? "";

        _searchCts?.Cancel();
        _searchCts?.Dispose();

        _searchCts = new CancellationTokenSource();
        var ct = _searchCts.Token;

        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(150, ct);
                if (!ct.IsCancellationRequested)
                    VM.SetSearch(q);
            }
            catch { }
        }, ct);
    }

    private bool _isRendering;
    private async void OnVmChanged()
    {
        if (_isRendering) return;
        _isRendering = true;

        await InvokeAsync(async () =>
        {
            ApplyOnlineSnapshot();
            StateHasChanged();
            await Task.Delay(50); // منع الـ Flicker
            _isRendering = false;
        });
    }

   
    private void OnRoomUpdatedDirect(RoomUpdatedModel upd)
    {
        Console.WriteLine($"[RoomsPage] RoomUpdated DIRECT RECEIVED: RoomId={upd.RoomId}");
        _ = InvokeAsync(StateHasChanged); // لو الـ VM مش كفاية
    }
    public async ValueTask DisposeAsync()
    {
        VM.Changed -= OnVmChanged;
        UnsubscribeRealtime();

        _searchCts?.Cancel();
        _searchCts?.Dispose();

        // تنظيف إضافي إذا احتجت
        _onlineMap.Clear();
        _typingMap.Clear();
    }
    public void Dispose()
    {
        // Sync cleanup - ابقى زي ما هو أو أضف تنظيف إضافي
        VM.Changed -= OnVmChanged;
        UnsubscribeRealtime();
        _searchCts?.Cancel();
        _searchCts?.Dispose();
    }
}
